<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Graphicmath" rel="Chapter" href="Graphicmath.html"><title>Graphicmath.Reduc</title>
</head>
<body>
<code class="code"><span class="keyword">struct</span><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Introduction"><h1>Introduction</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(**
The mathematician will find in this module methods in order to:
<p>
<ul>
<li>calculate with univariate polynomials with real or complex coefficients,</li>
</ul>
<ul>
<li>calculate with complex matrices,</li>
</ul>
<ul>
<li>calculate with polynomials of matrices,</li>
</ul>
<ul>
<li>approximate eigenvalues and eigenvectors of matrices,</li>
</ul>
<ul>
<li>separate nilpotent and diagonalizable parts of a matrix,</li>
</ul>
<ul>
<li>approximate roots of polynomials.</li>
</ul>

Various tradeoffs between speed and presision are possible.
Some calculus in extended precision necessitate the module <code class="code">sci.ml</code> which depends on the module <code class="code">nums.cma</code> from the standard Ocaml distribution.
<p>

<span id="2_Conventions"><h2>Conventions</h2></span>
<p>

Univariate polynomial are line-vectors (see the module <a href="Matrix.html"> matrix.ml</a>) containing the coefficients.
The coefficients are taken in the basis <code class="code">(<span class="constructor">X</span>^i)</code>, for <code class="code">i</code> natural integer.
<p>

Complex numbers are square matrices of order 2 with coefficients of type <code class="code">float</code> of the form
<p>

<code class="code">[| [| x ; -y |] ;

 [| y ; x|] |]. ***</code>
<p>

Complex matrices are real matrices of quadruple size orgnized as before where <code class="code">x</code> and <code class="code">y</code> represent respectively
the real and imaginary parts.
<p>

Complex vectors may be represented by double-size float vectors with imaginary part coming in the second half.
They may be represented too by real matrices with two columns as before <code class="code">***</code> or by complex polynomials.
<p>

Complex polynomials are arrays of complex numbers.
<p>

Some translating functions with the type <code class="code"><span class="constructor">Complex</span>.t</code> of Ocaml are provided, 
and functions applying functions of the <code class="code"><span class="constructor">Complex</span></code> module of Ocaml (like Complex.exp or Complex.arg) are provided too.
<p>

Gauss integers are square matrices of order 2 with coefficients of type <code class="code">int</code> with the same form <code class="code">***</code>.
<p>

The degree and valuation of a polynomial are of type <code class="code">float</code> in order to ease the arithmetic with infinity.
<p>

<span id="2_Comments"><h2>Comments</h2></span>
<p>

The Jordan decomposition algorithm is described in:
<p>

<code class="code">www.lsv.ens-cachan.fr/~picaro/<span class="constructor">COURS</span>/<span class="constructor">MG</span>/<span class="constructor">DIVERS</span>/dunford.pdf</code>
<p>

The approximating seek of the roots of a polynomial may produce a failure if:
<p>
<ul>
<li>some distinct roots are close of one another,</li>
<li>the multiplicities are high,</li>
<li>the degree of the polynomial is high.</li>
</ul>

The combination of all these factors increases the difficulty. 
<p>

A shifted seek of the eigenvalues may enhance the results.
<p>

This module is distributed under the same licence as Ocaml.
<p>

<center>§ </center>
<p>

La mathématicienne ou le mathématicien trouvera dans ce module des méthodes pour :
<p>
<ul>
<li>calculer avec des polynômes à une variable à coefficients réels ou complexes,</li>
</ul>
<ul>
<li>calculer avec des matrices complexes,</li>
</ul>
<ul>
<li>calculer avec des polynômes de matrices,</li>
</ul>
<ul>
<li>approximer des valeurs et vecteurs propres de matrices,</li>
</ul>
<ul>
<li>séparer parties nilpotente et diagonalisable d'une matrice,</li>
</ul>
<ul>
<li>approximer des racines de polynômes.</li>
</ul>

Différents compromis entre vitesse et précision sont possibles.
Certains calculs en précision étendue font appel au module <code class="code">sci.ml</code> qui dépend du module <code class="code">nums.cma</code> de la distribution Ocaml normale.
<p>

<span id="2_Conventions"><h2>Conventions</h2></span>
<p>

Les polynômes à une variable sont des vecteurs lignes (confer le module <a href="Matrix.html"> matrix.ml</a>) qui contiennent les coefficients.
Les coefficients sont dans la base <code class="code">(<span class="constructor">X</span>^i)</code>, pour <code class="code">i</code> entier naturel.
<p>

Les nombres complexes sont des matrices carrées d'ordre 2 à coefficients de type <code class="code">float</code>, sous la forme
<p>

<code class="code">[| [| x ; -y |] ;

 [| y ; x|] |]. ***</code>
<p>

Les matrices complexes sont des matrices réelles de taille quadruple organisées comme ci-dessus où <code class="code">x</code> et <code class="code">y</code>
représentent respectivement les parties réelle et complexe.
<p>

Les vecteurs complexes peuvent être représentés par des vecteurs réels de taille double dont la partie imaginaire vient dans la deuxième moitié.
Ils peuvent aussi être représentés par des matrices réelles à deux colonnes comme ci-dessus <code class="code">***</code> ou comme des polynômes complexes.
<p>

Les polynômes complexes sont des tableaux de nombres complexes.
<p>

Des fonctions de traduction avec le type <code class="code"><span class="constructor">Complex</span>.t</code> d'Ocaml sont fournies, 
et aussi des fonctions d'application des fonctions du module <code class="code"><span class="constructor">Complex</span></code> (comme Complex.exp ou Complex.arg).
<p>

Les entiers de Gauss sont des matrices carrées d'ordre 2 à coefficients de type <code class="code">int</code> sous la même forme <code class="code">***</code>.
<p>

Les degré et valuation d'un polynôme sont de type <code class="code">float</code> pour faciliter l'arithmétique avec l'infini.
<p>

<span id="2_Commentaires"><h2>Commentaires</h2></span>
<p>

L'algorithme de décomposition de Jordan est décrit dans :
<p>

<code class="code">www.lsv.ens-cachan.fr/~picaro/<span class="constructor">COURS</span>/<span class="constructor">MG</span>/<span class="constructor">DIVERS</span>/dunford.pdf</code>
<p>

La recherche approchée des racines d'un polynôme peut être mise en échec si : 
<p>
<ul>
<li>des racines distinctes sont proches,</li>
<li>les multiplicités sont élevées, </li>
<li>le degré du polynôme est élevé. </li>
</ul>

La combinaison de ces facteurs augmente encore la difficulté. 
<p>

Une recherche avec décalage (shift) des valeurs propres peut améliorer les résultats.
<p>

Ce module est distribué selon la même licence qu'Ocaml.
<p>

<center>Copyright Stéphane Grognet </center>
<center>Laboratoire de mathématiques Jean Leray UMR 6629 CNRS </center>
<center>Fédération de recherche mathématique des Pays de la Loire </center>
<center>IREM des Pays de la Loire - Université de Nantes </center>
<center>version 0.4</center>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(**
@version 0.4
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(**
@author Stéphane Grognet
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(**
@since 2011, 2012, 2013
*)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Util</span>&nbsp;;;<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Matrix</span>&nbsp;;;<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Sci</span>&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Constructionslmentaires"><h1>Constructions élémentaires</h1></span>
<span id="1_Elementaryconstructions"><h1>Elementary constructions</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Complexes"><h2>Complexes</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>built_in_complex_to_matrix complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;built_in_complex_to_matrix&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:<span class="constructor">Complex</span>.t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;z.<span class="constructor">Complex</span>.re<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;z.<span class="constructor">Complex</span>.im&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;-.&nbsp;y&nbsp;|]&nbsp;;&nbsp;[|&nbsp;y&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>apply_built_in_complex_to_matrix function complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;apply_built_in_complex_to_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(f:<span class="constructor">Complex</span>.t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Complex</span>.t)&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;{&nbsp;<span class="constructor">Complex</span>.re&nbsp;=&nbsp;z.(0).(0)&nbsp;;&nbsp;<span class="constructor">Complex</span>.im&nbsp;=&nbsp;z.(1).(0)&nbsp;}&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zzz&nbsp;=&nbsp;f&nbsp;zz&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;zzz.<span class="constructor">Complex</span>.re<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;zzz.<span class="constructor">Complex</span>.im&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;-.&nbsp;y&nbsp;|]&nbsp;;&nbsp;[|&nbsp;y&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>apply_built_in_complex_float_to_matrix function complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;apply_built_in_complex_float_to_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(f:<span class="constructor">Complex</span>.t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;float)&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;{&nbsp;<span class="constructor">Complex</span>.re&nbsp;=&nbsp;z.(0).(0)&nbsp;;&nbsp;<span class="constructor">Complex</span>.im&nbsp;=&nbsp;z.(1).(0)&nbsp;}&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;f&nbsp;zz&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>polar_to_matrix modulus argument</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;polar_to_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:float)&nbsp;(t:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;r&nbsp;*.&nbsp;(&nbsp;cos&nbsp;t&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;r&nbsp;*.&nbsp;(&nbsp;sin&nbsp;t&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;-.&nbsp;y&nbsp;|]&nbsp;;&nbsp;[|&nbsp;y&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>apply2_built_in_complex_to_matrix function complex1 complex2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;apply2_built_in_complex_to_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(f:<span class="constructor">Complex</span>.t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Complex</span>.t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Complex</span>.t)&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;(w:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;{&nbsp;<span class="constructor">Complex</span>.re&nbsp;=&nbsp;z.(0).(0)&nbsp;;&nbsp;<span class="constructor">Complex</span>.im&nbsp;=&nbsp;z.(1).(0)&nbsp;}<br>
&nbsp;<span class="keyword">and</span>&nbsp;ww&nbsp;=&nbsp;{&nbsp;<span class="constructor">Complex</span>.re&nbsp;=&nbsp;w.(0).(0)&nbsp;;&nbsp;<span class="constructor">Complex</span>.im&nbsp;=&nbsp;w.(1).(0)&nbsp;}&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zzz&nbsp;=&nbsp;f&nbsp;zz&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;zzz.<span class="constructor">Complex</span>.re<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;zzz.<span class="constructor">Complex</span>.im&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;-.&nbsp;y&nbsp;|]&nbsp;;&nbsp;[|&nbsp;y&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>float_to_complex float</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;float_to_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;0.&nbsp;|]&nbsp;;&nbsp;[|&nbsp;0.&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_to_complex float</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_to_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
[|&nbsp;[|&nbsp;float&nbsp;x&nbsp;;&nbsp;0.&nbsp;|]&nbsp;;&nbsp;[|&nbsp;0.&nbsp;;&nbsp;float&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>clean_complex complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;clean_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;z.(0).(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;a&nbsp;+.&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;b&nbsp;-.&nbsp;c&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;-.&nbsp;y&nbsp;|]&nbsp;;&nbsp;[|&nbsp;y&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_inv_bis complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_inv_bis&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Matrix</span>.float_tune_inv&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_inf&nbsp;z&nbsp;(&nbsp;<span class="constructor">Matrix</span>.float_inv&nbsp;z&nbsp;)&nbsp;).(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_inv_ter parameter complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_inv_ter&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(parameter:float)&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;y0&nbsp;=&nbsp;built_in_complex_to_matrix&nbsp;(&nbsp;<span class="constructor">Complex</span>.inv&nbsp;{<span class="constructor">Complex</span>.re=z.(0).(0)&nbsp;;&nbsp;<span class="constructor">Complex</span>.im=z.(1).(0)}&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;y1&nbsp;=&nbsp;complex_inv_bis&nbsp;z&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;(&nbsp;clean_complex&nbsp;y1&nbsp;)&nbsp;(&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;parameter&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;y1&nbsp;y0&nbsp;)&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_inv complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_inv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_inv_ter&nbsp;2.&nbsp;z&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_slow_inv complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_slow_inv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Matrix</span>.float_target_inv&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_frobenius&nbsp;complex_inv&nbsp;0.&nbsp;z&nbsp;).(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_div complex1 complex2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;(zz:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;(&nbsp;complex_inv&nbsp;zz&nbsp;)&nbsp;z&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_module complex</pre> This function permits to measurate the errors when getting away from the
complex structure because of the cumulated errors on the matrix computing.
<p>

Cette fonction permet de mesurer les erreurs quand on s'éloigne de la structure complexe
à cause des erreurs cumulées sur les calculs de matrices. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_module&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;z.(0).(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;sqrt&nbsp;(&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;a&nbsp;*.&nbsp;a&nbsp;+.&nbsp;b&nbsp;*.&nbsp;b&nbsp;+.&nbsp;c&nbsp;*.&nbsp;c&nbsp;+.&nbsp;d&nbsp;*.&nbsp;d&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_square_module complex</pre> This function permits to measurate the errors when getting away from the
complex structure because of the cumulated errors on the matrix computing.
<p>

Cette fonction permet de mesurer les erreurs quand on s'éloigne de la structure complexe
à cause des erreurs cumulées sur les calculs de matrices. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_square_module&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;z.(0).(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;a&nbsp;*.&nbsp;a&nbsp;+.&nbsp;b&nbsp;*.&nbsp;b&nbsp;+.&nbsp;c&nbsp;*.c&nbsp;+.&nbsp;d&nbsp;*.&nbsp;d&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_abs_max complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_abs_max&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;abs_float&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;abs_float&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;abs_float&nbsp;z.(0).(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;abs_float&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_max&nbsp;[|&nbsp;a&nbsp;;&nbsp;b&nbsp;;&nbsp;c&nbsp;;&nbsp;d&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_abs_sum complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_abs_sum&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;abs_float&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;abs_float&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;abs_float&nbsp;z.(0).(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;abs_float&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;a&nbsp;+.&nbsp;b&nbsp;+.&nbsp;c&nbsp;+.&nbsp;d&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_real_part complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;a&nbsp;+.&nbsp;d&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_imaginary_part complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_imaginary_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;b&nbsp;=&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;z.(0).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;b&nbsp;-.&nbsp;c&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_solve_degree_2 a b c</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_solve_degree_2&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(a:float&nbsp;array&nbsp;array)&nbsp;(b:float&nbsp;array&nbsp;array)&nbsp;(c:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;bb&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;b&nbsp;(&nbsp;float_to_complex&nbsp;(-0.5)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;bb&nbsp;bb&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;a&nbsp;c&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_square_module&nbsp;d&nbsp;=&nbsp;0.&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;complex_div&nbsp;bb&nbsp;a&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;x&nbsp;;&nbsp;x&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;apply_built_in_complex_to_matrix&nbsp;<span class="constructor">Complex</span>.sqrt&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;bb&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;bb&nbsp;dd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;complex_square_module&nbsp;m<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;complex_square_module&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;pp&nbsp;&gt;=&nbsp;mm&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;complex_div&nbsp;p&nbsp;a&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;x&nbsp;;&nbsp;complex_div&nbsp;c&nbsp;p&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;complex_div&nbsp;m&nbsp;a&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;complex_div&nbsp;c&nbsp;m&nbsp;;&nbsp;x&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_complex_solve_degree_2 a b c</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_complex_solve_degree_2&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(a:float&nbsp;array&nbsp;array)&nbsp;(b:float&nbsp;array&nbsp;array)&nbsp;(c:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;<span class="constructor">Sci</span>.solve_degree_2_1024&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;a&nbsp;)&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;b&nbsp;)&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;c&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_trace matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_trace&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:&nbsp;float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_cut&nbsp;2&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mmm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_foa_demakeup&nbsp;mm.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.foa_trace&nbsp;mmm.(0).(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;tt&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.foa_trace&nbsp;mmm.(1).(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;t&nbsp;;&nbsp;-.&nbsp;tt&nbsp;|]&nbsp;;&nbsp;[|&nbsp;tt&nbsp;;&nbsp;t&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_real_part matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rrrr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;cccc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;rrrr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;cc&nbsp;=&nbsp;cccc&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rrr&nbsp;=&nbsp;rrrr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ccc&nbsp;=&nbsp;cccc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;0&nbsp;r&nbsp;0&nbsp;c<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;xx&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;r&nbsp;rrr&nbsp;cc&nbsp;ccc&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;0.5&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;x&nbsp;xx&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_imag_part matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_imag_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rrrr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;cccc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;rrrr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;cc&nbsp;=&nbsp;cccc&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rrr&nbsp;=&nbsp;rrrr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ccc&nbsp;=&nbsp;cccc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;rr&nbsp;rrr&nbsp;0&nbsp;c<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;yy&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;0&nbsp;r&nbsp;cc&nbsp;ccc&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;0.5&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;y&nbsp;yy&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complexify matrix1 matrix2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complexify&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;(y:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;[|&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;x&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;y&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;y&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;x&nbsp;|]&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_foa_crash&nbsp;(&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Foa_matrix_cons</span>&nbsp;m&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_saturate num_rows num_columns complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_saturate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(c:int)&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;r&nbsp;c&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;r&nbsp;c&nbsp;z.(1).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_real_to_complex matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_real_to_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Matrix</span>.zeros_float&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;x&nbsp;z&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_imag_to_complex matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_imag_to_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Matrix</span>.zeros_float&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;z&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_complex num_rows num_columns complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_complex&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(c:int)&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;r&nbsp;c&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;r&nbsp;c&nbsp;z.(1).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_jordan order complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_jordan&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(n:int)&nbsp;(z:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;scal_complex&nbsp;n&nbsp;n&nbsp;z&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;-&nbsp;2&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;x.(i).(&nbsp;i&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;1.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;x.(nn).(&nbsp;nn&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;1.&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_scal_mult complex polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_scal_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;(v:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v<br>
&nbsp;<span class="keyword">and</span>&nbsp;zz&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;zz&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;x&nbsp;v.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;vv&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_scal_left_div complex polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_scal_left_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;(v:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v<br>
&nbsp;<span class="keyword">and</span>&nbsp;zz&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;zz&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;(&nbsp;complex_inv&nbsp;x&nbsp;)&nbsp;v.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;vv&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_scal_right_div complex polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_scal_right_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;(v:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v<br>
&nbsp;<span class="keyword">and</span>&nbsp;zz&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;zz&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;x&nbsp;(&nbsp;complex_inv&nbsp;v.(i)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;vv&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_scal_mult complex matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_scal_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;xx&nbsp;=&nbsp;scal_complex&nbsp;l&nbsp;l&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;xx&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_scal_left_div complex matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_scal_left_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;xx&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_inv&nbsp;(&nbsp;scal_complex&nbsp;l&nbsp;l&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;xx&nbsp;m&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_norm_inf polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_norm_inf&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_module&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_inf&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_norm_inf_bis polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_norm_inf_bis&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_inf&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_inf&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_norm_1 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_norm_1&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_module&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_1&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_norm_1_bis polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_norm_1_bis&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_1&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_1&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_norm_2 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_norm_2&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_module&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_square_norm_2 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_square_norm_2&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_square_module&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_sum&nbsp;v&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_EntiersdeGauss"><h2>Entiers de Gauss</h2></span>
<span id="2_Gaussintegers"><h2>Gauss integers</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_to_gauss integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_to_gauss&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
[|&nbsp;[|&nbsp;x&nbsp;;&nbsp;0&nbsp;|]&nbsp;;&nbsp;[|&nbsp;0&nbsp;;&nbsp;x&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_inv gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_inv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.int_inv&nbsp;z&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_div gauss_integer1 gauss_integer2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;(zz:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;(&nbsp;gauss_inv&nbsp;zz&nbsp;)&nbsp;z&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_square_module gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_square_module&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;z.(0).(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;a&nbsp;*&nbsp;a&nbsp;+&nbsp;b&nbsp;*&nbsp;b&nbsp;+&nbsp;c&nbsp;*&nbsp;c&nbsp;+&nbsp;d&nbsp;*&nbsp;d&nbsp;)&nbsp;/&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_real_part gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;z.(1).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;a&nbsp;+&nbsp;d&nbsp;)&nbsp;/&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_imaginary_part gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_imaginary_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;b&nbsp;=&nbsp;z.(1).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;z.(0).(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;b&nbsp;-&nbsp;c&nbsp;)&nbsp;/&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_trace matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_trace&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:&nbsp;int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_cut&nbsp;2&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mmm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_ioa_demakeup&nbsp;mm.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Matrix</span>.int_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.ioa_trace&nbsp;mmm.(0).(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;tt&nbsp;=&nbsp;<span class="constructor">Matrix</span>.int_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.ioa_trace&nbsp;mmm.(1).(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;t&nbsp;;&nbsp;-&nbsp;tt&nbsp;|]&nbsp;;&nbsp;[|&nbsp;tt&nbsp;;&nbsp;t&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_real_part matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rrrr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;cccc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;rrrr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;cc&nbsp;=&nbsp;cccc&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rrr&nbsp;=&nbsp;rrrr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ccc&nbsp;=&nbsp;cccc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;0&nbsp;r&nbsp;0&nbsp;c<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;xx&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;r&nbsp;rrr&nbsp;cc&nbsp;ccc&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_scal_left_div&nbsp;2&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;x&nbsp;xx&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_imag_part matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_imag_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rrrr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;cccc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;rrrr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;cc&nbsp;=&nbsp;cccc&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rrr&nbsp;=&nbsp;rrrr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ccc&nbsp;=&nbsp;cccc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;rr&nbsp;rrr&nbsp;0&nbsp;c<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;yy&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sub_matrix&nbsp;m&nbsp;0&nbsp;r&nbsp;cc&nbsp;ccc&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_scal_left_div&nbsp;2&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_minus&nbsp;y&nbsp;yy&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_complexify matrix1 matrix2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_complexify&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:int&nbsp;array&nbsp;array)&nbsp;(y:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;[|&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;x&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_opp&nbsp;y&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;y&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;x&nbsp;|]&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_ioa_crash&nbsp;(&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Ioa_matrix_cons</span>&nbsp;m&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_real_to_gauss matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_real_to_gauss&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Matrix</span>.zeros_int&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_gauss_complexify&nbsp;x&nbsp;z&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_imag_to_gauss matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_imag_to_gauss&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Matrix</span>.zeros_int&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_gauss_complexify&nbsp;z&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_gauss num_rows num_columns gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_gauss&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(c:int)&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;r&nbsp;c&nbsp;z.(0).(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;r&nbsp;c&nbsp;z.(1).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_gauss_complexify&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_jordan order gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_jordan&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(n:int)&nbsp;(z:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;scal_gauss&nbsp;n&nbsp;n&nbsp;z&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;-&nbsp;2&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;x.(i).(&nbsp;i&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;x.(nn).(&nbsp;nn&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_scal_mult gauss_integer polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_scal_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:int&nbsp;array&nbsp;array)&nbsp;(v:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v<br>
&nbsp;<span class="keyword">and</span>&nbsp;zz&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;zz&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;x&nbsp;v.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;vv&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_scal_mult gauss_integer matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_scal_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:int&nbsp;array&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;xx&nbsp;=&nbsp;scal_gauss&nbsp;l&nbsp;l&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;xx&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_scal_left_div gauss_integer matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_scal_left_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:int&nbsp;array&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;xx&nbsp;=&nbsp;<span class="constructor">Matrix</span>.int_inv&nbsp;(&nbsp;scal_gauss&nbsp;l&nbsp;l&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;xx&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_norm_inf polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_norm_inf&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Matrix</span>.matrix_int_norm_inf&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_int_norm_inf&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_norm_1 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_norm_1&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Matrix</span>.matrix_int_norm_1&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_int_norm_1&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_square_norm_2 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_square_norm_2&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;gauss_square_module&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_int_sum&nbsp;v&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Constantes"><h2>Constantes</h2></span>
<span id="2_Constants"><h2>Constants</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_1</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_1&nbsp;=&nbsp;<span class="constructor">Matrix</span>.identity_float&nbsp;2&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_minus_1</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_minus_1&nbsp;=&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;2&nbsp;2&nbsp;(-1.)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_0</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_0&nbsp;=&nbsp;<span class="constructor">Matrix</span>.null_float&nbsp;2&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_i</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_i&nbsp;=&nbsp;[|&nbsp;[|&nbsp;0.&nbsp;;&nbsp;-1.&nbsp;|]&nbsp;;&nbsp;[|&nbsp;1.&nbsp;;&nbsp;0.&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_1</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_1&nbsp;=&nbsp;<span class="constructor">Matrix</span>.identity_int&nbsp;2&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_minus_1</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_minus_1&nbsp;=&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;2&nbsp;2&nbsp;(-1)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_0</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_0&nbsp;=&nbsp;<span class="constructor">Matrix</span>.null_int&nbsp;2&nbsp;2&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_i</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_i&nbsp;=&nbsp;[|&nbsp;[|&nbsp;0&nbsp;;&nbsp;-1&nbsp;|]&nbsp;;&nbsp;[|&nbsp;1&nbsp;;&nbsp;0&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_x</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_x&nbsp;=&nbsp;[|&nbsp;0.&nbsp;;&nbsp;1.&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_x_power integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_x_power&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;1.&nbsp;|]<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;poly_real_x<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;w.(n)&nbsp;&lt;-&nbsp;1.&nbsp;;<br>
&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_x_a a</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_x_a&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(a:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;[|&nbsp;-.&nbsp;a&nbsp;;&nbsp;1.&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_x</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_x&nbsp;=&nbsp;[|&nbsp;0&nbsp;;&nbsp;1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_x_power integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_x_power&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;1&nbsp;|]<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;poly_int_x<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;w.(n)&nbsp;&lt;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_x_a a</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_x_a&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(a:int)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;-&nbsp;a&nbsp;;&nbsp;1&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_x</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_x&nbsp;=&nbsp;[|&nbsp;complex_0&nbsp;;&nbsp;complex_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_x_power integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_x_power&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;complex_1&nbsp;|]<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;poly_complex_x<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;w.(n)&nbsp;&lt;-&nbsp;complex_1&nbsp;;<br>
&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_x_a a</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_x_a&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(a:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;a&nbsp;;&nbsp;complex_1&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_x</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_x&nbsp;=&nbsp;[|&nbsp;gauss_0&nbsp;;&nbsp;gauss_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_x_power integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_x_power&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;gauss_1&nbsp;|]<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;poly_gauss_x<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;gauss_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;w.(n)&nbsp;&lt;-&nbsp;gauss_1&nbsp;;<br>
&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_x_a a</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_x_a&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(a:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_int_opp&nbsp;a&nbsp;;&nbsp;gauss_1&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_x</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_x&nbsp;=&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_x_power integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_x_power&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;|]<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;poly_sci_x<br>
&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;w.(n)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;;<br>
&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_x_a a</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_x_a&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(a:<span class="constructor">Num</span>.num&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.opp&nbsp;a&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;|]&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Oprationslmentaires"><h1>Opérations élémentaires</h1></span>
<span id="1_Elementaryoperations"><h1>Elementary operations</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Oprationspolymorphessurlespolynmes"><h2>Opérations polymorphes sur les polynômes</h2></span>
<span id="2_Polymorphicoperationsonpolynomials"><h2>Polymorphic operations on polynomials</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>extract_even_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;extract_even_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;r&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;r&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(&nbsp;2&nbsp;*&nbsp;i&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>extract_odd_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;extract_odd_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;r&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;r&nbsp;/&nbsp;2&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(&nbsp;2&nbsp;*&nbsp;i&nbsp;+&nbsp;1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Oprationspolymorphessurlesmatrices"><h2>Opérations polymorphes sur les matrices</h2></span>
<span id="2_Polymorphicoperationsonmatrices"><h2>Polymorphic operations on matrices</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_coefficient row column matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_coefficient&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:int)&nbsp;(j:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;n&nbsp;+&nbsp;i<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;jj&nbsp;=&nbsp;n&nbsp;+&nbsp;j<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;first_row.(j)&nbsp;;&nbsp;first_row.(jj)&nbsp;|]&nbsp;;&nbsp;[|&nbsp;second_row.(j)&nbsp;;&nbsp;second_row.(jj)&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_row_to_poly row_number matrix</pre> This function may apply to complex coefficients
(float array array) or Gauss integer coefficients (int array array).
<p>

Cette fonction peut être appliquée aux complexes (float array array) ou aux entiers de Gauss (int array array). *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_row_to_poly&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;c&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;m.(0).(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;c&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;c&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(j)&nbsp;&lt;-&nbsp;[|&nbsp;[|&nbsp;first_row.(j)&nbsp;;&nbsp;first_row.(jj)&nbsp;|]&nbsp;;&nbsp;[|&nbsp;second_row.(j)&nbsp;;&nbsp;second_row.(jj)&nbsp;|]&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_row_to_vector row_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_row_to_vector&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;<span class="keyword">and</span>&nbsp;cc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;cc&nbsp;m.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;c&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;c&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(j)&nbsp;&lt;-&nbsp;m.(i).(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(jj)&nbsp;&lt;-&nbsp;m.(ii).(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_row_to_matrix row_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_row_to_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;cc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;cc&nbsp;2&nbsp;m.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;c&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;c&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(j)&nbsp;&lt;-&nbsp;[|&nbsp;first_row.(j)&nbsp;;&nbsp;first_row.(jj)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(jj)&nbsp;&lt;-&nbsp;[|&nbsp;second_row.(j)&nbsp;;&nbsp;second_row.(jj)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_row_to_matrix_trans row_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_row_to_matrix_trans&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;m.(i)<br>
&nbsp;<span class="keyword">and</span>&nbsp;second&nbsp;=&nbsp;m.(&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;+&nbsp;i&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;cc&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;first&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;cc&nbsp;m.(0).(0)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;cc&nbsp;m.(0).(0)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;cc&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;c&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;c&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(j)&nbsp;&lt;-&nbsp;first.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(jj)&nbsp;&lt;-&nbsp;second.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.(j)&nbsp;&lt;-&nbsp;first.(jj)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.(jj)&nbsp;&lt;-&nbsp;second.(jj)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;x&nbsp;;&nbsp;y&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_column_to_poly row_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_column_to_poly&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(j:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;+&nbsp;j<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;r&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;m.(0).(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(i)&nbsp;&lt;-&nbsp;[|&nbsp;[|&nbsp;first_row.(j)&nbsp;;&nbsp;first_row.(jj)&nbsp;|]&nbsp;;&nbsp;[|&nbsp;second_row.(j)&nbsp;;&nbsp;second_row.(jj)&nbsp;|]&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_column_to_vector column_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_column_to_vector&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(j:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;m.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(i)&nbsp;&lt;-&nbsp;m.(i).(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(ii)&nbsp;&lt;-&nbsp;m.(ii).(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_column_to_matrix column_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_column_to_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(j:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;rr&nbsp;2&nbsp;m.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(i)&nbsp;&lt;-&nbsp;[|&nbsp;first_row.(j)&nbsp;;&nbsp;first_row.(jj)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(ii)&nbsp;&lt;-&nbsp;[|&nbsp;second_row.(j)&nbsp;;&nbsp;second_row.(jj)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_column_to_matrix_trans column_number matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_column_to_matrix_trans&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(j:int)&nbsp;m&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;m.(0).(0)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;m.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;/&nbsp;2&nbsp;)&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(i)&nbsp;&lt;-&nbsp;first_row.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.(ii)&nbsp;&lt;-&nbsp;second_row.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.(i)&nbsp;&lt;-&nbsp;first_row.(jj)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.(ii)&nbsp;&lt;-&nbsp;second_row.(jj)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;x&nbsp;;&nbsp;y&nbsp;|]&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Oprationslmentairessurlesmatricescomplexes"><h2>Opérations élémentaires sur les matrices complexes</h2></span>
<span id="2_Elementaryoperationsoncomplexmatrices"><h2>Elementary operations on complex matrices</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_extract_diag_to_poly matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_extract_diag_to_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;min&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;)&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;d.(i)&nbsp;&lt;-&nbsp;matrix_complex_extract_coefficient&nbsp;i&nbsp;i&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;d&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_contraction polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_contraction&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(v:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;complex_1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;v&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!accu&nbsp;v.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_hermitian_product vector1 vector2</pre> The vectors must have the form of real matrices with two rows.
<p>

Les vecteurs doivent être sous forme de matrices réelles à deux lignes. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_hermitian_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(u:float&nbsp;array&nbsp;array)&nbsp;(v:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;v&nbsp;u&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>diag_complex polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;diag_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nnn&nbsp;=&nbsp;2&nbsp;*&nbsp;n<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;nnn&nbsp;nnn&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;nn&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;n&nbsp;+&nbsp;i<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;x.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(i)&nbsp;&lt;-&nbsp;coeff.(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(ii)&nbsp;&lt;-&nbsp;coeff.(0).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(ii)&nbsp;&lt;-&nbsp;coeff.(1).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(i)&nbsp;&lt;-&nbsp;coeff.(1).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_non_diagonality norm matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_non_diagonality&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;distance&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;diag_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;m&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;distance&nbsp;mm&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_non_diagonal_part matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_non_diagonal_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;diag_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;m&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_i_times vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_i_times&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;v.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;w.(i)&nbsp;&lt;-&nbsp;-.&nbsp;v.(ii)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;w.(ii)&nbsp;&lt;-&nbsp;v.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_complex_to_matrix vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_complex_to_matrix&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;[|&nbsp;v&nbsp;;&nbsp;vector_complex_i_times&nbsp;v&nbsp;|]&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_OprationslmentairessurlesmatricescoefficientsentiersdeGauss"><h2>Opérations élémentaires sur les matrices à coefficients entiers de Gauss</h2></span>
<span id="2_ElementaryoperationsonmatriceswithGaussintegercoefficients"><h2>Elementary operations on matrices with Gauss integer coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_extract_diag_to_poly matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_extract_diag_to_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;min&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;)&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;gauss_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;d.(i)&nbsp;&lt;-&nbsp;matrix_complex_extract_coefficient&nbsp;i&nbsp;i&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;d&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_contraction vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_contraction&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(v:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;gauss_1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;v&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;!accu&nbsp;v.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_hermitian_product vector1 vector2</pre> The vectors must have the form of real matrices with two rows.
<p>

Les vecteurs doivent être sous forme de matrices réelles à deux lignes. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_hermitian_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(u:int&nbsp;array&nbsp;array)&nbsp;(v:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.matrix_int_twisted_prod&nbsp;v&nbsp;u&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>diag_gauss polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;diag_gauss&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nnn&nbsp;=&nbsp;2&nbsp;*&nbsp;n<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;nnn&nbsp;nnn&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;nn&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;n&nbsp;+&nbsp;i<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;x.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;second_row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(i)&nbsp;&lt;-&nbsp;coeff.(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(ii)&nbsp;&lt;-&nbsp;coeff.(0).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(ii)&nbsp;&lt;-&nbsp;coeff.(1).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(i)&nbsp;&lt;-&nbsp;coeff.(1).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_non_diagonality norm matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_non_diagonality&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;distance&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_minus&nbsp;m&nbsp;(&nbsp;diag_gauss&nbsp;(&nbsp;matrix_gauss_extract_diag_to_poly&nbsp;m&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;distance&nbsp;mm&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_non_diagonal_part matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_non_diagonal_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Matrix</span>.matrix_int_minus&nbsp;m&nbsp;(&nbsp;diag_gauss&nbsp;(&nbsp;matrix_gauss_extract_diag_to_poly&nbsp;m&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_i_times vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_i_times&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rr&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;v.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;r&nbsp;+&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;w.(i)&nbsp;&lt;-&nbsp;-&nbsp;v.(ii)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;w.(ii)&nbsp;&lt;-&nbsp;v.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>vector_gauss_to_matrix vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;vector_gauss_to_matrix&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;[|&nbsp;v&nbsp;;&nbsp;vector_gauss_i_times&nbsp;v&nbsp;|]&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Oprationslmentairessurlespolynmes"><h2>Opérations élémentaires sur les polynômes</h2></span>
<span id="2_Elementaryoperationsonpolynomials"><h2>Elementary operations on polynomials</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Polynmescoefficientsrels"><h3>Polynômes à coefficients réels</h3></span>
<span id="3_Polynomialswithrealcoefficients"><h3>Polynomials with real coefficients</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_deg polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_deg&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;deg&nbsp;=&nbsp;ref&nbsp;neg_infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&lt;&gt;&nbsp;0.&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;abs_float&nbsp;coeff&nbsp;&gt;&nbsp;max_float&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;deg&nbsp;:=&nbsp;infinity&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;deg&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!deg&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_val polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_val&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;valuation&nbsp;=&nbsp;ref&nbsp;infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&lt;&gt;&nbsp;0.&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;abs_float&nbsp;coeff&nbsp;&gt;&nbsp;max_float&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;neg_infinity&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!valuation&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_cleanup polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_cleanup&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_real_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;0.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_normalize polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_normalize&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_real_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;0.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;1.&nbsp;/.&nbsp;p.(dd)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;*.&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_deriv polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_deriv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;pp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r.(&nbsp;i&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;(&nbsp;float&nbsp;i&nbsp;)&nbsp;*.&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_plus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_plus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;0.&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;0.&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_plus&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_minus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_minus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;0.&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;0.&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_float_minus&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_mult polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qqq&nbsp;=&nbsp;qq&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;pp&nbsp;+&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;qq&nbsp;0.&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;0.&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;!accu&nbsp;+.&nbsp;x.(j)&nbsp;*.&nbsp;y.(&nbsp;i&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_mult_karatsuba threshold polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_real_mult_karatsuba&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:int)&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ll&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l_l&nbsp;=&nbsp;max&nbsp;l&nbsp;ll&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;l_l&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;poly_real_mult&nbsp;p&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;half&nbsp;=&nbsp;(&nbsp;l_l&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p_p&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;l&nbsp;)&nbsp;0.&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q_q&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;ll&nbsp;)&nbsp;0.&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;debut&nbsp;=&nbsp;poly_real_mult_karatsuba&nbsp;threshold&nbsp;pp&nbsp;qq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fin&nbsp;=&nbsp;poly_real_mult_karatsuba&nbsp;threshold&nbsp;ppp&nbsp;qqq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;psum&nbsp;=&nbsp;poly_real_plus&nbsp;pp&nbsp;ppp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qsum&nbsp;=&nbsp;poly_real_plus&nbsp;qq&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mix&nbsp;=&nbsp;poly_real_mult_karatsuba&nbsp;threshold&nbsp;psum&nbsp;qsum&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;inter&nbsp;=&nbsp;poly_real_minus&nbsp;mix&nbsp;debut&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;milieu&nbsp;=&nbsp;poly_real_minus&nbsp;inter&nbsp;fin&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;poly_real_plus&nbsp;debut&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;half&nbsp;)&nbsp;0.&nbsp;)&nbsp;milieu&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;raw_prod&nbsp;=&nbsp;poly_real_plus&nbsp;first&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;half&nbsp;)&nbsp;0.&nbsp;)&nbsp;fin&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_real_cleanup&nbsp;raw_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_pow mult_rule power polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_real_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;1.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mult_rule&nbsp;p&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_real_pow&nbsp;mult_rule&nbsp;nn&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prod&nbsp;=&nbsp;mult_rule&nbsp;pp&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_rule&nbsp;prod&nbsp;p<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_finite_prod mult_rule polynomial_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_real_finite_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;mult_rule&nbsp;!q&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_from_roots mult_rule roots_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_from_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(r:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_real_x_a&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_real_finite_prod&nbsp;mult_rule&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_horner_comp polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;pp&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;pp&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_real_plus&nbsp;(&nbsp;poly_real_mult&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(i)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_ranged_horner_comp mult_rule index order polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_ranged_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(i:int)&nbsp;(l:int)&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;l&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_real_plus&nbsp;(&nbsp;mult_rule&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;j&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_brent_kung_hart_novocin_comp mult_rule parameter polynomial1 polynomial2</pre> The length <code class="code">l</code> must be greater than or equal to <code class="code">3</code>.
The algorithm comes from the document located at the following address.
<p>

<code class="code">http://hal-ens-lyon.archives-ouvertes.fr/docs/00/54/61/02/<span class="constructor">PDF</span>/dmtcs_NOVOCIN2010.pdf</code>
<p>

L'algorithme provient du document situé à l'adresse précédente.
La longueur <code class="code">l</code> doit être supérieure ou égale à <code class="code">3</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_brent_kung_hart_novocin_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(l:int)&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_real_pow&nbsp;mult_rule&nbsp;l&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;!k&nbsp;*&nbsp;l&nbsp;-&nbsp;n&nbsp;)&nbsp;0.&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;1&nbsp;+&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;pp&nbsp;)&nbsp;)&nbsp;/&nbsp;l&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;hh&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;0.&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_real_ranged_horner_comp&nbsp;mult_rule&nbsp;(&nbsp;j&nbsp;*&nbsp;l&nbsp;)&nbsp;l&nbsp;pp&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;!k&nbsp;+&nbsp;1&nbsp;)/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hh.(j)&nbsp;&lt;-&nbsp;poly_real_plus&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;)&nbsp;(&nbsp;mult_rule&nbsp;!g&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;+&nbsp;1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;hh.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;:=&nbsp;mult_rule&nbsp;!g&nbsp;!g&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_evaluate comp_rule polynomial real</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_evaluate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;comp_rule&nbsp;(p:float&nbsp;array)&nbsp;(x0:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;comp_rule&nbsp;p&nbsp;[|&nbsp;x0&nbsp;|]&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_sylvester_matrix polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_sylvester_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_real_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;dq&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_real_deg&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;dp&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;dd&nbsp;dd&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dq&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.(j)&nbsp;&lt;-&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.(j)&nbsp;&lt;-&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_resultant det_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_resultant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;real_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;det_methode&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_discriminant det_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_discriminant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;real_resultant&nbsp;det_methode&nbsp;p&nbsp;(&nbsp;poly_real_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Polynmescoefficientsentiers"><h3>Polynômes à coefficients entiers</h3></span>
<span id="3_Polynomialswithintegercoefficients"><h3>Polynomials with integer coefficients</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_deg polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_deg&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;deg&nbsp;=&nbsp;ref&nbsp;neg_infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;p.(!r)&nbsp;&lt;&gt;&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;deg&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!deg&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_val polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_val&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;valuation&nbsp;=&nbsp;ref&nbsp;infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;p.(!r)&nbsp;&lt;&gt;&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!valuation&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_cleanup polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_cleanup&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_int_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_deriv polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_deriv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;pp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r.(&nbsp;i&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;i&nbsp;*&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_plus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_plus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;0&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_int_plus&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_minus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_minus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;0&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.vector_int_minus&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_mult polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qqq&nbsp;=&nbsp;qq&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;pp&nbsp;+&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;qq&nbsp;0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;!accu&nbsp;+&nbsp;x.(j)&nbsp;*&nbsp;y.(&nbsp;i&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_mult_karatsuba threshold polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_int_mult_karatsuba&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:int)&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ll&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l_l&nbsp;=&nbsp;max&nbsp;l&nbsp;ll&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;l_l&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;poly_int_mult&nbsp;p&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;half&nbsp;=&nbsp;(&nbsp;l_l&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p_p&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;l&nbsp;)&nbsp;0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q_q&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;ll&nbsp;)&nbsp;0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;debut&nbsp;=&nbsp;poly_int_mult_karatsuba&nbsp;threshold&nbsp;pp&nbsp;qq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fin&nbsp;=&nbsp;poly_int_mult_karatsuba&nbsp;threshold&nbsp;ppp&nbsp;qqq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;psum&nbsp;=&nbsp;poly_int_plus&nbsp;pp&nbsp;ppp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qsum&nbsp;=&nbsp;poly_int_plus&nbsp;qq&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mix&nbsp;=&nbsp;poly_int_mult_karatsuba&nbsp;threshold&nbsp;psum&nbsp;qsum&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;inter&nbsp;=&nbsp;poly_int_minus&nbsp;mix&nbsp;debut&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;milieu&nbsp;=&nbsp;poly_int_minus&nbsp;inter&nbsp;fin&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;poly_int_plus&nbsp;debut&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;half&nbsp;)&nbsp;0&nbsp;)&nbsp;milieu&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;raw_prod&nbsp;=&nbsp;poly_int_plus&nbsp;first&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;half&nbsp;)&nbsp;0&nbsp;)&nbsp;fin&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_int_cleanup&nbsp;raw_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_pow mult_rule power polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_int_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mult_rule&nbsp;p&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_int_pow&nbsp;mult_rule&nbsp;nn&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prod&nbsp;=&nbsp;mult_rule&nbsp;pp&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_rule&nbsp;prod&nbsp;p<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_finite_prod mult_rule polynomial_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_int_finite_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;mult_rule&nbsp;!q&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_from_roots mult_rule roots_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_from_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(r:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_int_x_a&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_int_finite_prod&nbsp;mult_rule&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_horner_comp polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;pp&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;pp&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_int_plus&nbsp;(&nbsp;poly_int_mult&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(i)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_ranged_horner_comp mult_rule index order polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_ranged_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(i:int)&nbsp;(l:int)&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;l&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_int_plus&nbsp;(&nbsp;mult_rule&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;j&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_brent_kung_hart_novocin_comp mult_rule parameter polynomial1 polynomial2</pre> The length <code class="code">l</code> must be greater than or equal to <code class="code">3</code>.
The algorithm comes from the document located at the following address.
<p>

<code class="code">http://hal-ens-lyon.archives-ouvertes.fr/docs/00/54/61/02/<span class="constructor">PDF</span>/dmtcs_NOVOCIN2010.pdf</code>
<p>

L'algorithme provient du document situé à l'adresse précédente.
La longueur <code class="code">l</code> doit être supérieure ou égale à <code class="code">3</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_int_brent_kung_hart_novocin_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(l:int)&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_int_pow&nbsp;mult_rule&nbsp;l&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;!k&nbsp;*&nbsp;l&nbsp;-&nbsp;n&nbsp;)&nbsp;0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;1&nbsp;+&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;pp&nbsp;)&nbsp;)&nbsp;/&nbsp;l&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;hh&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;0&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_int_ranged_horner_comp&nbsp;mult_rule&nbsp;(&nbsp;j&nbsp;*&nbsp;l&nbsp;)&nbsp;l&nbsp;pp&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;!k&nbsp;+&nbsp;1&nbsp;)/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hh.(j)&nbsp;&lt;-&nbsp;poly_int_plus&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;)&nbsp;(&nbsp;mult_rule&nbsp;!g&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;+&nbsp;1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_int_copy&nbsp;hh.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;:=&nbsp;mult_rule&nbsp;!g&nbsp;!g&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_evaluate comp_rule polynomial integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_evaluate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;comp_rule&nbsp;(p:int&nbsp;array)&nbsp;(x0:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;comp_rule&nbsp;p&nbsp;[|&nbsp;x0&nbsp;|]&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_sylvester_matrix polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_sylvester_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_int_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;dq&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_int_deg&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;dp&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;dd&nbsp;dd&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dq&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.(j)&nbsp;&lt;-&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;row&nbsp;=&nbsp;m.(ii)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.(j)&nbsp;&lt;-&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_resultant det_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_resultant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;int_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;det_methode&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_discriminant det_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_discriminant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;int_resultant&nbsp;det_methode&nbsp;p&nbsp;(&nbsp;poly_int_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Polynmescoefficientscomplexes"><h3>Polynômes à coefficients complexes</h3></span>
<span id="3_Polynomialswithcomplexcoefficients"><h3>Polynomials with complex coefficients</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_deg polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_deg&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;deg&nbsp;=&nbsp;ref&nbsp;neg_infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_inf&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&lt;&gt;&nbsp;0.&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&gt;&nbsp;max_float&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;deg&nbsp;:=&nbsp;infinity&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;deg&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!deg&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_val polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_val&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;valuation&nbsp;=&nbsp;ref&nbsp;infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_inf&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&lt;&gt;&nbsp;0.&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&gt;&nbsp;max_float&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;neg_infinity&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!valuation&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_cleanup polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_cleanup&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;complex_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_normalize polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_normalize&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;complex_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;complex_1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;complex_inv&nbsp;p.(dd)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;p.(i)&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_copy polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_copy&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;r&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_copy&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_poly_to_complex_vector polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_poly_to_complex_vector&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;l&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(i)&nbsp;&lt;-&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;p.(i).(0).(0)&nbsp;+.&nbsp;p.(i).(1).(1)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;p.(i).(1).(0)&nbsp;-.&nbsp;p.(i).(0).(1)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_poly_to_complex_double_vector polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_poly_to_complex_double_vector&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;l&nbsp;)&nbsp;0.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;l&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(i)&nbsp;&lt;-&nbsp;p.(i).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;p.(i).(1).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(i)&nbsp;&lt;-&nbsp;p.(i).(0).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;p.(i).(1).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;v&nbsp;;&nbsp;vv&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_vector_to_complex_poly vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_vector_to_complex_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;v&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;p.(i)&nbsp;&lt;-&nbsp;[|&nbsp;[|&nbsp;v.(i)&nbsp;;&nbsp;-.&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;|]&nbsp;;&nbsp;[|&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;;&nbsp;v.(i)&nbsp;|]&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_deriv polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_deriv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;pp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r.(&nbsp;i&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;(&nbsp;float&nbsp;i&nbsp;)&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_plus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_plus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_minus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_minus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_mult polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qqq&nbsp;=&nbsp;qq&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;pp&nbsp;+&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;qq&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;x.(j)&nbsp;y.(&nbsp;i&nbsp;-&nbsp;j&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_mult_karatsuba threshold polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_complex_mult_karatsuba&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:int)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ll&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l_l&nbsp;=&nbsp;max&nbsp;l&nbsp;ll&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;l_l&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;poly_complex_mult&nbsp;p&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;half&nbsp;=&nbsp;(&nbsp;l_l&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p_p&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;l&nbsp;)&nbsp;complex_0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q_q&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;ll&nbsp;)&nbsp;complex_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;debut&nbsp;=&nbsp;poly_complex_mult_karatsuba&nbsp;threshold&nbsp;pp&nbsp;qq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fin&nbsp;=&nbsp;poly_complex_mult_karatsuba&nbsp;threshold&nbsp;ppp&nbsp;qqq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;psum&nbsp;=&nbsp;poly_complex_plus&nbsp;pp&nbsp;ppp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qsum&nbsp;=&nbsp;poly_complex_plus&nbsp;qq&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mix&nbsp;=&nbsp;poly_complex_mult_karatsuba&nbsp;threshold&nbsp;psum&nbsp;qsum&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;inter&nbsp;=&nbsp;poly_complex_minus&nbsp;mix&nbsp;debut&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;milieu&nbsp;=&nbsp;poly_complex_minus&nbsp;inter&nbsp;fin&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;poly_complex_plus&nbsp;debut&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;half&nbsp;)&nbsp;complex_0&nbsp;)&nbsp;milieu&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;raw_prod&nbsp;=&nbsp;poly_complex_plus&nbsp;first&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;half&nbsp;)&nbsp;complex_0&nbsp;)&nbsp;fin&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_complex_cleanup&nbsp;raw_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_pow mult_rule power polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_complex_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;complex_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mult_rule&nbsp;p&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_complex_pow&nbsp;mult_rule&nbsp;nn&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prod&nbsp;=&nbsp;mult_rule&nbsp;pp&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_rule&nbsp;prod&nbsp;p<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_finite_prod mult_rule polynomial_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_complex_finite_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;mult_rule&nbsp;!q&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_from_roots mult_rule roots_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_from_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(r:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_complex_x_a&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_complex_finite_prod&nbsp;mult_rule&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_horner_comp polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array&nbsp;)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;pp&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;pp&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_complex_plus&nbsp;(&nbsp;poly_complex_mult&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(i)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_ranged_horner_comp mult_rule index order polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_ranged_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(i:int)&nbsp;(l:int)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;l&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_complex_plus&nbsp;(&nbsp;mult_rule&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;j&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_brent_kung_hart_novocin_comp mult_rule parameter polynomial1 polynomial2</pre> The length <code class="code">l</code> must be greater than or equal to <code class="code">3</code>.
The algorithm comes from the document located at the following address.
<p>

<code class="code">http://hal-ens-lyon.archives-ouvertes.fr/docs/00/54/61/02/<span class="constructor">PDF</span>/dmtcs_NOVOCIN2010.pdf</code>
<p>

L'algorithme provient du document situé à l'adresse précédente.
La longueur <code class="code">l</code> doit être supérieure ou égale à <code class="code">3</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_brent_kung_hart_novocin_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(l:int)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_complex_pow&nbsp;mult_rule&nbsp;l&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;!k&nbsp;*&nbsp;l&nbsp;-&nbsp;n&nbsp;)&nbsp;complex_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;1&nbsp;+&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;pp&nbsp;)&nbsp;)&nbsp;/&nbsp;l&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;complex_0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;hh&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;complex_0&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_complex_ranged_horner_comp&nbsp;mult_rule&nbsp;(&nbsp;j&nbsp;*&nbsp;l&nbsp;)&nbsp;l&nbsp;pp&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;!k&nbsp;+&nbsp;1&nbsp;)/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hh.(j)&nbsp;&lt;-&nbsp;poly_complex_plus&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;)&nbsp;(&nbsp;mult_rule&nbsp;!g&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;+&nbsp;1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_complex_copy&nbsp;hh.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;:=&nbsp;mult_rule&nbsp;!g&nbsp;!g&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_evaluate comp_rule polynomial complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_evaluate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;comp_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(x0:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;comp_rule&nbsp;p&nbsp;[|&nbsp;x0&nbsp;|]&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_sylvester_matrix polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_sylvester_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;dq&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;dp&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;2&nbsp;*&nbsp;dd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;ddd&nbsp;ddd&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dq&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;second_row&nbsp;=&nbsp;m.(&nbsp;dd&nbsp;+&nbsp;i&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;dd&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(j)&nbsp;&lt;-&nbsp;complex_real_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(jj)&nbsp;&lt;-&nbsp;-.&nbsp;complex_imaginary_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(j)&nbsp;&lt;-&nbsp;complex_imaginary_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(jj)&nbsp;&lt;-&nbsp;complex_real_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(ii)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;second_row&nbsp;=&nbsp;m.(&nbsp;dd&nbsp;+&nbsp;ii&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;dd&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(j)&nbsp;&lt;-&nbsp;complex_real_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(jj)&nbsp;&lt;-&nbsp;-.&nbsp;complex_imaginary_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(j)&nbsp;&lt;-&nbsp;complex_imaginary_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(jj)&nbsp;&lt;-&nbsp;complex_real_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_resultant det_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_resultant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;det_methode&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_discriminant det_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_discriminant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;complex_resultant&nbsp;det_methode&nbsp;p&nbsp;(&nbsp;poly_complex_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_PolynmescoefficientsentiersdeGauss"><h3>Polynômes à coefficients entiers de Gauss</h3></span>
<span id="3_PolynomialswithGaussintegercoefficients"><h3>Polynomials with Gauss integer coefficients</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_deg polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_deg&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;deg&nbsp;=&nbsp;ref&nbsp;neg_infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_norm_inf&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&lt;&gt;&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;deg&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!deg&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_val polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_val&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;valuation&nbsp;=&nbsp;ref&nbsp;infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_norm_inf&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;coeff&nbsp;&lt;&gt;&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!valuation&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_cleanup polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_cleanup&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_gauss_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;gauss_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;gauss_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_copy polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_copy&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;r&nbsp;gauss_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_int_copy&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_poly_to_gauss_vector polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_poly_to_gauss_vector&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;l&nbsp;)&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(i)&nbsp;&lt;-&nbsp;(&nbsp;p.(i).(0).(0)&nbsp;+&nbsp;p.(i).(1).(1)&nbsp;)&nbsp;/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;(&nbsp;p.(i).(1).(0)&nbsp;-&nbsp;p.(i).(0).(1)&nbsp;)&nbsp;/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_poly_to_gauss_double_vector polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_poly_to_gauss_double_vector&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;l&nbsp;)&nbsp;0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;l&nbsp;)&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(i)&nbsp;&lt;-&nbsp;p.(i).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;p.(i).(1).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(i)&nbsp;&lt;-&nbsp;p.(i).(0).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vv.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;p.(i).(1).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;v&nbsp;;&nbsp;vv&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_vector_to_gauss_poly vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_vector_to_gauss_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;v&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;gauss_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;p.(i)&nbsp;&lt;-&nbsp;[|&nbsp;[|&nbsp;v.(i)&nbsp;;&nbsp;-&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;|]&nbsp;;&nbsp;[|&nbsp;v.(&nbsp;l&nbsp;+&nbsp;i&nbsp;)&nbsp;;&nbsp;v.(i)&nbsp;|]&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_deriv polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_deriv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;pp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r.(&nbsp;i&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_int_scal_mult&nbsp;i&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_plus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_plus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_minus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_minus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_int_minus&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_mult polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qqq&nbsp;=&nbsp;qq&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;pp&nbsp;+&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;qq&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;x.(j)&nbsp;y.(&nbsp;i&nbsp;-&nbsp;j&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;2&nbsp;2&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_mult_karatsuba threshold polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_gauss_mult_karatsuba&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:int)&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ll&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l_l&nbsp;=&nbsp;max&nbsp;l&nbsp;ll&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;l_l&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;poly_gauss_mult&nbsp;p&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;half&nbsp;=&nbsp;(&nbsp;l_l&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p_p&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;l&nbsp;)&nbsp;gauss_0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q_q&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;ll&nbsp;)&nbsp;gauss_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;debut&nbsp;=&nbsp;poly_gauss_mult_karatsuba&nbsp;threshold&nbsp;pp&nbsp;qq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fin&nbsp;=&nbsp;poly_gauss_mult_karatsuba&nbsp;threshold&nbsp;ppp&nbsp;qqq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;psum&nbsp;=&nbsp;poly_gauss_plus&nbsp;pp&nbsp;ppp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qsum&nbsp;=&nbsp;poly_gauss_plus&nbsp;qq&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mix&nbsp;=&nbsp;poly_gauss_mult_karatsuba&nbsp;threshold&nbsp;psum&nbsp;qsum&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;inter&nbsp;=&nbsp;poly_gauss_minus&nbsp;mix&nbsp;debut&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;milieu&nbsp;=&nbsp;poly_gauss_minus&nbsp;inter&nbsp;fin&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;poly_gauss_plus&nbsp;debut&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;half&nbsp;)&nbsp;gauss_0&nbsp;)&nbsp;milieu&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;raw_prod&nbsp;=&nbsp;poly_gauss_plus&nbsp;first&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;half&nbsp;)&nbsp;gauss_0&nbsp;)&nbsp;fin&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_gauss_cleanup&nbsp;raw_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_pow mult_rule power polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_gauss_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;gauss_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mult_rule&nbsp;p&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_gauss_pow&nbsp;mult_rule&nbsp;nn&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prod&nbsp;=&nbsp;mult_rule&nbsp;pp&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_rule&nbsp;prod&nbsp;p<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_finite_prod mult_rule polynomial_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_gauss_finite_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;mult_rule&nbsp;!q&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_from_roots mult_rule roots_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_from_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(r:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_gauss_x_a&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_gauss_finite_prod&nbsp;mult_rule&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_horner_comp polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array&nbsp;)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;pp&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;pp&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_gauss_plus&nbsp;(&nbsp;poly_gauss_mult&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(i)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_ranged_horner_comp mult_rule index order polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_ranged_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(i:int)&nbsp;(l:int)&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;l&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_gauss_plus&nbsp;(&nbsp;mult_rule&nbsp;!res&nbsp;q&nbsp;)&nbsp;[|&nbsp;p.(&nbsp;i&nbsp;+&nbsp;j&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_brent_kung_hart_novocin_comp mult_rule parameter polynomial1 polynomial2</pre> The length <code class="code">l</code> must be greater than or equal to <code class="code">3</code>.
The algorithm comes from the document located at the following address.
<p>

<code class="code">http://hal-ens-lyon.archives-ouvertes.fr/docs/00/54/61/02/<span class="constructor">PDF</span>/dmtcs_NOVOCIN2010.pdf</code>
<p>

L'algorithme provient du document situé à l'adresse précédente.
La longueur <code class="code">l</code> doit être supérieure ou égale à <code class="code">3</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_gauss_brent_kung_hart_novocin_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(l:int)&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_gauss_pow&nbsp;mult_rule&nbsp;l&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;!k&nbsp;*&nbsp;l&nbsp;-&nbsp;n&nbsp;)&nbsp;gauss_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;1&nbsp;+&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;pp&nbsp;)&nbsp;)&nbsp;/&nbsp;l&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;gauss_0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;hh&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;gauss_0&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_gauss_ranged_horner_comp&nbsp;mult_rule&nbsp;(&nbsp;j&nbsp;*&nbsp;l&nbsp;)&nbsp;l&nbsp;pp&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;!k&nbsp;+&nbsp;1&nbsp;)/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hh.(j)&nbsp;&lt;-&nbsp;poly_gauss_plus&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;)&nbsp;(&nbsp;mult_rule&nbsp;!g&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;+&nbsp;1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_gauss_copy&nbsp;hh.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;:=&nbsp;mult_rule&nbsp;!g&nbsp;!g&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_evaluate comp_rule polynomial gauss_integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_evaluate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;comp_rule&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(x0:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;comp_rule&nbsp;p&nbsp;[|&nbsp;x0&nbsp;|]&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_sylvester_matrix polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_sylvester_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_gauss_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;dq&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_gauss_deg&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;dp&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;2&nbsp;*&nbsp;dd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;ddd&nbsp;ddd&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dq&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;second_row&nbsp;=&nbsp;m.(&nbsp;dd&nbsp;+&nbsp;i&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;dd&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(j)&nbsp;&lt;-&nbsp;gauss_real_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(jj)&nbsp;&lt;-&nbsp;-&nbsp;gauss_imaginary_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(j)&nbsp;&lt;-&nbsp;gauss_imaginary_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(jj)&nbsp;&lt;-&nbsp;gauss_real_part&nbsp;p.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;dq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;m.(ii)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;second_row&nbsp;=&nbsp;m.(&nbsp;dd&nbsp;+&nbsp;ii&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;i&nbsp;<span class="keyword">to</span>&nbsp;ii&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;dd&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(j)&nbsp;&lt;-&nbsp;gauss_real_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(jj)&nbsp;&lt;-&nbsp;-&nbsp;gauss_imaginary_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(j)&nbsp;&lt;-&nbsp;gauss_imaginary_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(jj)&nbsp;&lt;-&nbsp;gauss_real_part&nbsp;q.(&nbsp;ii&nbsp;-&nbsp;j&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_resultant det_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_resultant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;gauss_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;det_methode&nbsp;m&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_discriminant det_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_discriminant&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;det_methode&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;gauss_resultant&nbsp;det_methode&nbsp;p&nbsp;(&nbsp;poly_gauss_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Polynmescoefficientsenprcisiontendue"><h3>Polynômes à coefficients en précision étendue</h3></span>
<span id="3_Polynomialswithcoefficientsinextendedprecision"><h3>Polynomials with coefficients in extended precision</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_deg polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_deg&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;deg&nbsp;=&nbsp;ref&nbsp;neg_infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.square_module&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Sci</span>.not_eq_0&nbsp;coeff&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deg&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;-1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;-&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!deg&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_val polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_val&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;valuation&nbsp;=&nbsp;ref&nbsp;infinity&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">then</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!r&nbsp;&lt;=&nbsp;rr&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.square_module&nbsp;p.(!r)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Sci</span>.not_eq_0&nbsp;coeff&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;valuation&nbsp;:=&nbsp;float&nbsp;!r&nbsp;;&nbsp;r&nbsp;:=&nbsp;max_int&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;r&nbsp;:=&nbsp;!r&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!valuation&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_cleanup polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_cleanup&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_normalize polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_normalize&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv&nbsp;p.(dd)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.mult&nbsp;p.(i)&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_copy polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_copy&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;r&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;r&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_deriv polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_deriv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;pp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r.(&nbsp;i&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.mult&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;i&nbsp;)&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_plus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_plus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.plus&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_minus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_minus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.minus&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_mult polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qqq&nbsp;=&nbsp;qq&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;pp&nbsp;+&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;qq&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Sci</span>.plus&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;x.(j)&nbsp;y.(&nbsp;i&nbsp;-&nbsp;j&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_mult_karatsuba threshold polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_sci_mult_karatsuba&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ll&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l_l&nbsp;=&nbsp;max&nbsp;l&nbsp;ll&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;l_l&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;poly_sci_mult&nbsp;p&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;half&nbsp;=&nbsp;(&nbsp;l_l&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p_p&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;l&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q_q&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;ll&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;debut&nbsp;=&nbsp;poly_sci_mult_karatsuba&nbsp;threshold&nbsp;pp&nbsp;qq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fin&nbsp;=&nbsp;poly_sci_mult_karatsuba&nbsp;threshold&nbsp;ppp&nbsp;qqq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;psum&nbsp;=&nbsp;poly_sci_plus&nbsp;pp&nbsp;ppp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qsum&nbsp;=&nbsp;poly_sci_plus&nbsp;qq&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mix&nbsp;=&nbsp;poly_sci_mult_karatsuba&nbsp;threshold&nbsp;psum&nbsp;qsum&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;inter&nbsp;=&nbsp;poly_sci_minus&nbsp;mix&nbsp;debut&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;milieu&nbsp;=&nbsp;poly_sci_minus&nbsp;inter&nbsp;fin&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;poly_sci_plus&nbsp;debut&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;half&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;milieu&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;raw_prod&nbsp;=&nbsp;poly_sci_plus&nbsp;first&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;half&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;fin&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_sci_cleanup&nbsp;raw_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_pow mult_rule power polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_sci_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mult_rule&nbsp;p&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_pow&nbsp;mult_rule&nbsp;nn&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prod&nbsp;=&nbsp;mult_rule&nbsp;pp&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_rule&nbsp;prod&nbsp;p<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_finite_prod mult_rule polynomial_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_sci_finite_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;mult_rule&nbsp;!q&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_from_roots mult_rule roots_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_from_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(r:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_sci_x_a&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_sci_finite_prod&nbsp;mult_rule&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_horner_comp polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array&nbsp;)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(&nbsp;pp&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;pp&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_sci_plus&nbsp;(&nbsp;poly_sci_mult&nbsp;!res&nbsp;q&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(i)&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_ranged_horner_comp mult_rule index order polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_ranged_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(i:int)&nbsp;(l:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(&nbsp;i&nbsp;+&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;l&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_sci_plus&nbsp;(&nbsp;mult_rule&nbsp;!res&nbsp;q&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(&nbsp;i&nbsp;+&nbsp;j&nbsp;)&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_brent_kung_hart_novocin_comp mult_rule parameter polynomial1 polynomial2</pre> The length <code class="code">l</code> must be greater than or equal to <code class="code">3</code>.
The algorithm comes from the document located at the following address.
<p>

<code class="code">http://hal-ens-lyon.archives-ouvertes.fr/docs/00/54/61/02/<span class="constructor">PDF</span>/dmtcs_NOVOCIN2010.pdf</code>
<p>

L'algorithme provient du document situé à l'adresse précédente.
La longueur <code class="code">l</code> doit être supérieure ou égale à <code class="code">3</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_brent_kung_hart_novocin_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(l:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_pow&nbsp;mult_rule&nbsp;l&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;!k&nbsp;*&nbsp;l&nbsp;-&nbsp;n&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;1&nbsp;+&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;pp&nbsp;)&nbsp;)&nbsp;/&nbsp;l&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;hh&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_sci_ranged_horner_comp&nbsp;mult_rule&nbsp;(&nbsp;j&nbsp;*&nbsp;l&nbsp;)&nbsp;l&nbsp;pp&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;!k&nbsp;+&nbsp;1&nbsp;)/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hh.(j)&nbsp;&lt;-&nbsp;poly_sci_plus&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;)&nbsp;(&nbsp;mult_rule&nbsp;!g&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;+&nbsp;1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_sci_copy&nbsp;hh.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;:=&nbsp;mult_rule&nbsp;!g&nbsp;!g&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_evaluate comp_rule polynomial complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_evaluate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;comp_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(x0:<span class="constructor">Num</span>.num&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;comp_rule&nbsp;p&nbsp;[|&nbsp;x0&nbsp;|]&nbsp;).(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_eq_0 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_eq_0&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Array</span>.fold_left&nbsp;(<span class="keywordsign">&amp;&amp;</span>)&nbsp;<span class="keyword">true</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Sci</span>.square_module&nbsp;x&nbsp;).(0)&nbsp;=&nbsp;<span class="constructor">Sci</span>.num_0&nbsp;)&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_eq polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_eq&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_eq_0&nbsp;(&nbsp;poly_sci_minus&nbsp;p&nbsp;q&nbsp;)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Polynmescoefficientsenprcisionintermdiaire"><h3>Polynômes à coefficients en précision intermédiaire</h3></span>
<span id="3_Polynomialswithcoefficientsinintermediateprecision"><h3>Polynomials with coefficients in intermediate precision</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_normalize polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_normalize&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;p.(dd)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;p.(i)&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_deriv polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_deriv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;pp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r.(&nbsp;i&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;i&nbsp;)&nbsp;p.(i)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_plus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_plus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.plus_1024&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_minus polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_minus&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;max&nbsp;pp&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;pp&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;rr&nbsp;-&nbsp;qq&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.minus_1024&nbsp;x.(i)&nbsp;y.(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_mult polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qqq&nbsp;=&nbsp;qq&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;pp&nbsp;+&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;p&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;qq&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.concat&nbsp;[&nbsp;q&nbsp;;&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;pp&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;rr&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;rr&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Sci</span>.plus_1024&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;x.(j)&nbsp;y.(&nbsp;i&nbsp;-&nbsp;j&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_mult_karatsuba threshold polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_sci_1024_mult_karatsuba&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ll&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l_l&nbsp;=&nbsp;max&nbsp;l&nbsp;ll&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;l_l&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;poly_sci_1024_mult&nbsp;p&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;half&nbsp;=&nbsp;(&nbsp;l_l&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;p_p&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;l&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q_q&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l_l&nbsp;-&nbsp;ll&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p_p&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;0&nbsp;half<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;q_q&nbsp;half&nbsp;(&nbsp;l_l&nbsp;-&nbsp;half&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;debut&nbsp;=&nbsp;poly_sci_1024_mult_karatsuba&nbsp;threshold&nbsp;pp&nbsp;qq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fin&nbsp;=&nbsp;poly_sci_1024_mult_karatsuba&nbsp;threshold&nbsp;ppp&nbsp;qqq<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;psum&nbsp;=&nbsp;poly_sci_1024_plus&nbsp;pp&nbsp;ppp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qsum&nbsp;=&nbsp;poly_sci_1024_plus&nbsp;qq&nbsp;qqq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mix&nbsp;=&nbsp;poly_sci_1024_mult_karatsuba&nbsp;threshold&nbsp;psum&nbsp;qsum&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;inter&nbsp;=&nbsp;poly_sci_1024_minus&nbsp;mix&nbsp;debut&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;milieu&nbsp;=&nbsp;poly_sci_1024_minus&nbsp;inter&nbsp;fin&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first&nbsp;=&nbsp;poly_sci_1024_plus&nbsp;debut&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;half&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;milieu&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;raw_prod&nbsp;=&nbsp;poly_sci_1024_plus&nbsp;first&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;2&nbsp;*&nbsp;half&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;fin&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_sci_cleanup&nbsp;raw_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_pow mult_rule power polynomial</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_sci_1024_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;mult_rule&nbsp;p&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_1024_pow&nbsp;mult_rule&nbsp;nn&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prod&nbsp;=&nbsp;mult_rule&nbsp;pp&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_rule&nbsp;prod&nbsp;p<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_finite_prod mult_rule polynomial_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_sci_1024_finite_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;mult_rule&nbsp;!q&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!q&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_from_roots mult_rule roots_array</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_from_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(r:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_sci_x_a&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_sci_1024_finite_prod&nbsp;mult_rule&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_horner_comp polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array&nbsp;)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(&nbsp;pp&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;pp&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_sci_1024_plus&nbsp;(&nbsp;poly_sci_1024_mult&nbsp;!res&nbsp;q&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(i)&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_ranged_horner_comp mult_rule index order polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_ranged_horner_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(i:int)&nbsp;(l:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(&nbsp;i&nbsp;+&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;l&nbsp;-&nbsp;2&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;poly_sci_1024_plus&nbsp;(&nbsp;mult_rule&nbsp;!res&nbsp;q&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;p.(&nbsp;i&nbsp;+&nbsp;j&nbsp;)&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!res&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_brent_kung_hart_novocin_comp mult_rule parameter polynomial1 polynomial2</pre> The length <code class="code">l</code> must be greater than or equal to <code class="code">3</code>.
The algorithm comes from the document located at the following address.
<p>

<code class="code">http://hal-ens-lyon.archives-ouvertes.fr/docs/00/54/61/02/<span class="constructor">PDF</span>/dmtcs_NOVOCIN2010.pdf</code>
<p>

L'algorithme provient du document situé à l'adresse précédente.
La longueur <code class="code">l</code> doit être supérieure ou égale à <code class="code">3</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_brent_kung_hart_novocin_comp&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(l:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_1024_pow&nbsp;mult_rule&nbsp;l&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;ref&nbsp;(&nbsp;(&nbsp;n&nbsp;+&nbsp;1&nbsp;)&nbsp;/&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;!k&nbsp;*&nbsp;l&nbsp;-&nbsp;n&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;1&nbsp;+&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;pp&nbsp;)&nbsp;)&nbsp;/&nbsp;l&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;hh&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;(&nbsp;(&nbsp;!k&nbsp;+&nbsp;l&nbsp;)&nbsp;*&nbsp;2&nbsp;)&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_sci_1024_ranged_horner_comp&nbsp;mult_rule&nbsp;(&nbsp;j&nbsp;*&nbsp;l&nbsp;)&nbsp;l&nbsp;pp&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;:=&nbsp;(&nbsp;!k&nbsp;+&nbsp;1&nbsp;)/&nbsp;2&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hh.(j)&nbsp;&lt;-&nbsp;poly_sci_1024_plus&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;)&nbsp;(&nbsp;mult_rule&nbsp;!g&nbsp;h.(&nbsp;2&nbsp;*&nbsp;j&nbsp;+&nbsp;1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;!k&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(j)&nbsp;&lt;-&nbsp;poly_sci_copy&nbsp;hh.(j)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!k&nbsp;&gt;&nbsp;1&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;:=&nbsp;mult_rule&nbsp;!g&nbsp;!g&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_evaluate comp_rule polynomial complex</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_evaluate&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;comp_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(x0:<span class="constructor">Num</span>.num&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;comp_rule&nbsp;p&nbsp;[|&nbsp;x0&nbsp;|]&nbsp;).(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_eq_0 polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_eq_0&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Array</span>.fold_left&nbsp;(<span class="keywordsign">&amp;&amp;</span>)&nbsp;<span class="keyword">true</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Sci</span>.square_module_1024&nbsp;x&nbsp;).(0)&nbsp;=&nbsp;<span class="constructor">Sci</span>.num_0&nbsp;)&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_eq polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_eq&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_1024_eq_0&nbsp;(&nbsp;poly_sci_1024_minus&nbsp;p&nbsp;q&nbsp;)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Conversionsdetypes"><h3>Conversions de types</h3></span>
<span id="3_Typeconversions"><h3>Type conversions</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_to_complex polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_to_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;2&nbsp;2&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_to_gauss polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_to_gauss&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;2&nbsp;2&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_to_sci polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_to_sci&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_to_complex polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_to_complex&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_to_sci polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_to_sci&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
poly_complex_to_sci&nbsp;(&nbsp;poly_real_to_complex&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_real_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_imag_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_imag_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(1).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_real_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_imag_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_imag_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_real_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_real_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;x&nbsp;).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_imag_part polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_imag_part&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;x&nbsp;).(1).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;p&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Oprationsarithmtiquessurlespolynmes"><h1>Opérations arithmétiques sur les polynômes</h1></span>
<span id="1_Arithmeticoperationsonpolynomials"><h1>Arithmetic operations on polynomials</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Polynmescoefficientsrels"><h2>Polynômes à coefficients réels</h2></span>
<span id="2_Polynomialswithrealcoefficients"><h2>Polynomials with real coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_div polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(d:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_real_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ddd&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Division&nbsp;by&nbsp;zero&nbsp;in&nbsp;Reduc.poly_real_div."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_real_deg&nbsp;r&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dominant&nbsp;=&nbsp;d.(dd)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;max&nbsp;1&nbsp;(&nbsp;(&nbsp;int_of_float&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!dr&nbsp;&gt;=&nbsp;ddd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;drdr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;r.(&nbsp;drdr&nbsp;)&nbsp;/.&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(place)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;drdr&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;r.(i)&nbsp;-.&nbsp;coeff&nbsp;*.&nbsp;d.(&nbsp;i&nbsp;-&nbsp;place&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(drdr)&nbsp;&lt;-&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dr&nbsp;:=&nbsp;poly_real_deg&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_div_inc order polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_div_inc&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(order:int)&nbsp;(p:float&nbsp;array)&nbsp;(d:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_real_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;oo&nbsp;=&nbsp;float&nbsp;order<br>
&nbsp;<span class="keyword">and</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_real_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;d.(0)&nbsp;=&nbsp;0.&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Bad&nbsp;divisor&nbsp;in&nbsp;Reduc.poly_real_div_inc."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;dp&nbsp;+&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_real_val&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dominant&nbsp;=&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;1&nbsp;)&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!vr&nbsp;&lt;=&nbsp;oo&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vrvr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!vr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;r.(vrvr)&nbsp;/.&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(vrvr)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;r.(i)&nbsp;-.&nbsp;coeff&nbsp;*.&nbsp;d.(&nbsp;i&nbsp;-&nbsp;vrvr&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(vrvr)&nbsp;&lt;-&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vr&nbsp;:=&nbsp;poly_real_val&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_mod polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_mod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_real_cleanup&nbsp;(&nbsp;poly_real_div&nbsp;p&nbsp;q&nbsp;).(1)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_gcd polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_gcd&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_real_mod&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_real_mod&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;poly_real_deg&nbsp;r<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_real_deg&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_real_normalize&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_real_normalize&nbsp;p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;&lt;&nbsp;ss&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;pp&nbsp;:=&nbsp;q&nbsp;;&nbsp;qq&nbsp;:=&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;qq&nbsp;:=&nbsp;s&nbsp;)&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_real_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;poly_real_mod&nbsp;!pp&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!ppp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_real_normalize&nbsp;!pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_bezout mult_rule polynomial1 polynomial2</pre> The output yields in that order
the gcd <code class="code">d</code> and the Bézout coefficients <code class="code">u</code> and <code class="code">v</code> such that <code class="code">up+vq=d</code>.
<p>

La sortie fournit dans l'ordre le pgcd <code class="code">d</code> et les coefficients de Bézout <code class="code">u</code> et <code class="code">v</code> tels que <code class="code">up+vq=d</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_bezout&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_real_div&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_real_div&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;ref&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;[|&nbsp;1.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v&nbsp;=&nbsp;ref&nbsp;[|&nbsp;0.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uu&nbsp;=&nbsp;ref&nbsp;[|&nbsp;0.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;ref&nbsp;[|&nbsp;1.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uuu&nbsp;=&nbsp;ref&nbsp;[|&nbsp;1.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vvv&nbsp;=&nbsp;ref&nbsp;[|&nbsp;0.&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rr&nbsp;=&nbsp;poly_real_deg&nbsp;r.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_real_deg&nbsp;s.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_real_deg&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;1.&nbsp;/.&nbsp;q.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;x&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;[|&nbsp;1.&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;poly_real_minus&nbsp;[|&nbsp;x&nbsp;|]&nbsp;r.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!qq&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_real_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;1.&nbsp;/.&nbsp;p.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;x&nbsp;p&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;[|&nbsp;1.&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;poly_real_minus&nbsp;[|&nbsp;x&nbsp;|]&nbsp;s.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_real_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_real_div&nbsp;!pp&nbsp;!qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qqq&nbsp;:=&nbsp;d.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;!qqq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uuu&nbsp;:=&nbsp;poly_real_minus&nbsp;!u&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!uu&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;!uu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;!uuu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vvv&nbsp;:=&nbsp;poly_real_minus&nbsp;!v&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!vv&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;!vv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;!vvv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_real_deg&nbsp;!pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;1.&nbsp;/.&nbsp;!pp.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;x&nbsp;!pp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;x&nbsp;!u&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;x&nbsp;!v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!u&nbsp;;&nbsp;!v&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_lcm mult_rule polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_real_lcm&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_real_gcd&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;pq&nbsp;=&nbsp;mult_rule&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;poly_real_div&nbsp;pq&nbsp;d&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_simplify polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_simplify&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;poly_real_deriv&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;poly_real_gcd&nbsp;p&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;(&nbsp;poly_real_div&nbsp;p&nbsp;g&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Polynmescoefficientscomplexes"><h2>Polynômes à coefficients complexes</h2></span>
<span id="2_Polynomialswithcomplexcoefficients"><h2>Polynomials with complex coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_div polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(d:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_complex_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;poly_complex_copy&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ddd&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Division&nbsp;by&nbsp;zero&nbsp;in&nbsp;Reduc.poly_complex_div."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_complex_deg&nbsp;r&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dominant&nbsp;=&nbsp;complex_inv&nbsp;d.(dd)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;max&nbsp;1&nbsp;(&nbsp;(&nbsp;int_of_float&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;)&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!dr&nbsp;&gt;=&nbsp;ddd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;drdr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;r.(&nbsp;drdr&nbsp;)&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(place)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;drdr&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;r.(i)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;coeff&nbsp;d.(&nbsp;i&nbsp;-&nbsp;place&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(drdr)&nbsp;&lt;-&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dr&nbsp;:=&nbsp;poly_complex_deg&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_div_inc order polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_div_inc&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(order:int)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(d:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_complex_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;oo&nbsp;=&nbsp;float&nbsp;order<br>
&nbsp;<span class="keyword">and</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_inf&nbsp;d.(0)&nbsp;=&nbsp;0.&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Bad&nbsp;divisor&nbsp;in&nbsp;Reduc.poly_complex_div_inc."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;dp&nbsp;+&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_complex_val&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dominant&nbsp;=&nbsp;complex_inv&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;1&nbsp;)&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!vr&nbsp;&lt;=&nbsp;oo&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vrvr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!vr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;r.(vrvr)&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(vrvr)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;r.(i)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;coeff&nbsp;d.(&nbsp;i&nbsp;-&nbsp;vrvr&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(vrvr)&nbsp;&lt;-&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vr&nbsp;:=&nbsp;poly_complex_val&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_mod polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_mod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_complex_cleanup&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;q&nbsp;).(1)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_gcd polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_gcd&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_complex_mod&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_complex_mod&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;poly_complex_deg&nbsp;r<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_complex_deg&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_complex_normalize&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_complex_normalize&nbsp;p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;&lt;&nbsp;ss&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;pp&nbsp;:=&nbsp;q&nbsp;;&nbsp;qq&nbsp;:=&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;qq&nbsp;:=&nbsp;s&nbsp;)&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_complex_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;poly_complex_mod&nbsp;!pp&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!ppp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_complex_normalize&nbsp;!pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_bezout mult_rule polynomial1 polynomial2</pre> The output yields in that order
the gcd <code class="code">d</code> and the Bézout coefficients <code class="code">u</code> and <code class="code">v</code> such that <code class="code">up+vq=d</code>.
<p>

La sortie fournit dans l'ordre le pgcd <code class="code">d</code> et les coefficients de Bézout <code class="code">u</code> et <code class="code">v</code> tels que <code class="code">up+vq=d</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_bezout&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_complex_div&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_complex_div&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;ref&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uu&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uuu&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_1&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vvv&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_0&nbsp;|]<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rr&nbsp;=&nbsp;poly_complex_deg&nbsp;r.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_complex_deg&nbsp;s.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_complex_deg&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;complex_inv&nbsp;q.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;x&nbsp;)&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;[|&nbsp;complex_1&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;poly_complex_minus&nbsp;[|&nbsp;x&nbsp;|]&nbsp;r.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!qq&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;complex_inv&nbsp;p.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;x&nbsp;)&nbsp;p&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;[|&nbsp;complex_1&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;poly_complex_minus&nbsp;[|&nbsp;x&nbsp;|]&nbsp;s.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_complex_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_div&nbsp;!pp&nbsp;!qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qqq&nbsp;:=&nbsp;d.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;!qqq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uuu&nbsp;:=&nbsp;poly_complex_minus&nbsp;!u&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!uu&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;!uu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;!uuu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vvv&nbsp;:=&nbsp;poly_complex_minus&nbsp;!v&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!vv&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;!vv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;!vvv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_complex_deg&nbsp;!pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;complex_inv&nbsp;!pp.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;vector_complex_scal_mult&nbsp;x&nbsp;!pp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;vector_complex_scal_mult&nbsp;x&nbsp;!u&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;vector_complex_scal_mult&nbsp;x&nbsp;!v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!u&nbsp;;&nbsp;!v&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_lcm mult_rule polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_complex_lcm&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_gcd&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;pq&nbsp;=&nbsp;mult_rule&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;poly_complex_div&nbsp;pq&nbsp;d&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_simplify polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_simplify&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;poly_complex_deriv&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;poly_complex_gcd&nbsp;p&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;g&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Polynmescoefficientsenprcisiontendue"><h2>Polynômes à coefficients en précision étendue</h2></span>
<span id="2_Polynomialswithcoefficientsinextendedprecision"><h2>Polynomials with coefficients in extended precision</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_div polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(d:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_sci_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;poly_sci_copy&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ddd&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Division&nbsp;by&nbsp;zero&nbsp;in&nbsp;Reduc.poly_sci_div."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_deg&nbsp;r&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dominant&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv&nbsp;d.(dd)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;max&nbsp;1&nbsp;(&nbsp;(&nbsp;int_of_float&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!dr&nbsp;&gt;=&nbsp;ddd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;drdr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.mult&nbsp;r.(&nbsp;drdr&nbsp;)&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(place)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;drdr&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.minus&nbsp;r.(i)&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;coeff&nbsp;d.(&nbsp;i&nbsp;-&nbsp;place&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(drdr)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dr&nbsp;:=&nbsp;poly_sci_deg&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_div_inc order polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_div_inc&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(order:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(d:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_sci_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;oo&nbsp;=&nbsp;float&nbsp;order<br>
&nbsp;<span class="keyword">and</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Sci</span>.eq_0&nbsp;(&nbsp;<span class="constructor">Sci</span>.square_module&nbsp;d.(0)&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Bad&nbsp;divisor&nbsp;in&nbsp;Reduc.poly_sci_div_inc."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;dp&nbsp;+&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_val&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dominant&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!vr&nbsp;&lt;=&nbsp;oo&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vrvr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!vr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.mult&nbsp;r.(vrvr)&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(vrvr)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.minus&nbsp;r.(i)&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;coeff&nbsp;d.(&nbsp;i&nbsp;-&nbsp;vrvr&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(vrvr)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vr&nbsp;:=&nbsp;poly_sci_val&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_mod polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_mod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_cleanup&nbsp;(&nbsp;poly_sci_div&nbsp;p&nbsp;q&nbsp;).(1)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_gcd polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_gcd&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_sci_mod&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_sci_mod&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;poly_sci_deg&nbsp;r<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_sci_deg&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_sci_normalize&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_sci_normalize&nbsp;p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;&lt;&nbsp;ss&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;pp&nbsp;:=&nbsp;q&nbsp;;&nbsp;qq&nbsp;:=&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;qq&nbsp;:=&nbsp;s&nbsp;)&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_sci_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;poly_sci_mod&nbsp;!pp&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!ppp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_sci_normalize&nbsp;!pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_bezout mult_rule polynomial1 polynomial2</pre> The output yields in that order
the gcd <code class="code">d</code> and the Bézout coefficients <code class="code">u</code> and <code class="code">v</code> such that <code class="code">up+vq=d</code>.
<p>

La sortie fournit dans l'ordre le pgcd <code class="code">d</code> et les coefficients de Bézout <code class="code">u</code> et <code class="code">v</code> tels que <code class="code">up+vq=d</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_bezout&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_sci_div&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_sci_div&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_copy&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_copy&nbsp;q&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_copy&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uuu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vvv&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rr&nbsp;=&nbsp;poly_sci_deg&nbsp;r.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_sci_deg&nbsp;s.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_sci_deg&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv&nbsp;q.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;x&nbsp;)&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;poly_sci_minus&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;x&nbsp;)&nbsp;)&nbsp;r.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!qq&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv&nbsp;p.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;x&nbsp;)&nbsp;p&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;poly_sci_minus&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;x&nbsp;)&nbsp;)&nbsp;s.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_sci_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_div&nbsp;!pp&nbsp;!qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qqq&nbsp;:=&nbsp;d.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;!qqq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uuu&nbsp;:=&nbsp;poly_sci_minus&nbsp;!u&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!uu&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;!uu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;!uuu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vvv&nbsp;:=&nbsp;poly_sci_minus&nbsp;!v&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!vv&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;!vv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;!vvv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_sci_deg&nbsp;!pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv&nbsp;!pp.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;x&nbsp;)&nbsp;!pp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;x&nbsp;)&nbsp;!u&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;x&nbsp;)&nbsp;!v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!u&nbsp;;&nbsp;!v&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_lcm mult_rule polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_lcm&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_gcd&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;pq&nbsp;=&nbsp;mult_rule&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;poly_sci_div&nbsp;pq&nbsp;d&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_simplify polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_simplify&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;poly_sci_deriv&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;poly_sci_gcd&nbsp;p&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;(&nbsp;poly_sci_div&nbsp;p&nbsp;g&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="3_Polynmescoefficientsenprcisionintermdiaire"><h3>Polynômes à coefficients en précision intermédiaire</h3></span>
<span id="3_Polynomialswithcoefficientsinintermediateprecision"><h3>Polynomials with coefficients in intermediate precision</h3></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_div polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(d:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_sci_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;poly_sci_copy&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ddd&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Division&nbsp;by&nbsp;zero&nbsp;in&nbsp;Reduc.poly_sci_1024_div."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_deg&nbsp;r&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dominant&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;d.(dd)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;max&nbsp;1&nbsp;(&nbsp;(&nbsp;int_of_float&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!dr&nbsp;&gt;=&nbsp;ddd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;-&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;drdr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!dr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;r.(&nbsp;drdr&nbsp;)&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(place)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;drdr&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.minus_1024&nbsp;r.(i)&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;coeff&nbsp;d.(&nbsp;i&nbsp;-&nbsp;place&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(drdr)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dr&nbsp;:=&nbsp;poly_sci_deg&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_div_inc order polynomial1 polynomial2</pre> Output: quotient, remainder.
<p>

Sortie : quotient, reste. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_div_inc&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(order:int)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(d:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;ddd&nbsp;=&nbsp;poly_sci_deg&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;oo&nbsp;=&nbsp;float&nbsp;order<br>
&nbsp;<span class="keyword">and</span>&nbsp;dp&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Sci</span>.eq_0&nbsp;(&nbsp;<span class="constructor">Sci</span>.square_module_1024&nbsp;d.(0)&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Bad&nbsp;divisor&nbsp;in&nbsp;Reduc.poly_sci_1024_div_inc."</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;int_of_float&nbsp;ddd&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;dp&nbsp;+&nbsp;dd&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dp&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;p.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vr&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_val&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dominant&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;order&nbsp;+&nbsp;1&nbsp;)&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!vr&nbsp;&lt;=&nbsp;oo&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vrvr&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;!vr&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;place&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;r.(vrvr)&nbsp;dominant&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.(vrvr)&nbsp;&lt;-&nbsp;coeff&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;vrvr&nbsp;+&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;place&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.minus_1024&nbsp;r.(i)&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;coeff&nbsp;d.(&nbsp;i&nbsp;-&nbsp;vrvr&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.(vrvr)&nbsp;&lt;-&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vr&nbsp;:=&nbsp;poly_sci_val&nbsp;r&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;r&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_mod polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_mod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_cleanup&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;q&nbsp;).(1)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_gcd polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_gcd&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_sci_1024_mod&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_sci_1024_mod&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;ref&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;poly_sci_deg&nbsp;r<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_sci_deg&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_sci_1024_normalize&nbsp;q<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;poly_sci_1024_normalize&nbsp;p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;&lt;&nbsp;ss&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;pp&nbsp;:=&nbsp;q&nbsp;;&nbsp;qq&nbsp;:=&nbsp;r&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;qq&nbsp;:=&nbsp;s&nbsp;)&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_sci_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;poly_sci_1024_mod&nbsp;!pp&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!ppp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_sci_1024_normalize&nbsp;!pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_bezout mult_rule polynomial1 polynomial2</pre> The output yields in that order
the gcd <code class="code">d</code> and the Bézout coefficients <code class="code">u</code> and <code class="code">v</code> such that <code class="code">up+vq=d</code>.
<p>

La sortie fournit dans l'ordre le pgcd <code class="code">d</code> et les coefficients de Bézout <code class="code">u</code> et <code class="code">v</code> tels que <code class="code">up+vq=d</code>. *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_bezout&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;poly_sci_1024_div&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;poly_sci_1024_div&nbsp;q&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;pp&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_copy&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_copy&nbsp;q&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;(&nbsp;poly_sci_copy&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;uuu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vvv&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rr&nbsp;=&nbsp;poly_sci_deg&nbsp;r.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ss&nbsp;=&nbsp;poly_sci_deg&nbsp;s.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;rr&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_sci_deg&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;q.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;x&nbsp;)&nbsp;q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;poly_sci_1024_minus&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;x&nbsp;)&nbsp;)&nbsp;r.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!qq&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;ss&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;p.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;x&nbsp;)&nbsp;p&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;poly_sci_1024_minus&nbsp;(&nbsp;<span class="constructor">Array</span>.make&nbsp;1&nbsp;(&nbsp;<span class="constructor">Sci</span>.sci_copy&nbsp;x&nbsp;)&nbsp;)&nbsp;s.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!uu&nbsp;;&nbsp;!vv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;poly_sci_deg&nbsp;!qq&nbsp;&gt;=&nbsp;0.&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_1024_div&nbsp;!pp&nbsp;!qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qqq&nbsp;:=&nbsp;d.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;!qqq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uuu&nbsp;:=&nbsp;poly_sci_1024_minus&nbsp;!u&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!uu&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;!uu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uu&nbsp;:=&nbsp;!uuu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vvv&nbsp;:=&nbsp;poly_sci_1024_minus&nbsp;!v&nbsp;(&nbsp;mult_rule&nbsp;dd&nbsp;!vv&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;!vv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vv&nbsp;:=&nbsp;!vvv&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;degre&nbsp;=&nbsp;poly_sci_deg&nbsp;!pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;!pp.(&nbsp;int_of_float&nbsp;degre&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;x&nbsp;)&nbsp;!pp&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;x&nbsp;)&nbsp;!u&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;x&nbsp;)&nbsp;!v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!pp&nbsp;;&nbsp;!u&nbsp;;&nbsp;!v&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_lcm mult_rule polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_lcm&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(q:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_1024_gcd&nbsp;p&nbsp;q<br>
&nbsp;<span class="keyword">and</span>&nbsp;pq&nbsp;=&nbsp;mult_rule&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;poly_sci_1024_div&nbsp;pq&nbsp;d&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_simplify polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_simplify&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dp&nbsp;=&nbsp;poly_sci_1024_deriv&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;poly_sci_1024_gcd&nbsp;p&nbsp;dp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;g&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Oprationsentrelespolynmesetlesmatrices"><h1>Opérations entre les polynômes et les matrices</h1></span>
<span id="1_Operationsbetweenpolynomialsandmatrices"><h1>Operations between polynomials and matrices</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Coefficientsrels"><h2>Coefficients réels</h2></span>
<span id="2_Realcoefficients"><h2>Real coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_apply_matrix polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_apply_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_real_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;r&nbsp;r&nbsp;p.(d)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;m&nbsp;!mm&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!mm&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;r&nbsp;r&nbsp;p.(i)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!mm&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_apply_matrix_rec polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_real_apply_matrix_rec&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_real_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;=&nbsp;3&nbsp;<span class="keyword">then</span>&nbsp;poly_real_apply_matrix&nbsp;p&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;tail&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;head&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;dd&nbsp;(&nbsp;d&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_power&nbsp;dd&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mmm&nbsp;=&nbsp;poly_real_apply_matrix_rec&nbsp;head&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;(&nbsp;poly_real_apply_matrix_rec&nbsp;tail&nbsp;m&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;mm&nbsp;mmm&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_companion polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_companion&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_real_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;(-1.)&nbsp;/.&nbsp;p.(d)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;q.(i)&nbsp;*.&nbsp;coeff<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Matrix</span>.identity_float_bis&nbsp;(&nbsp;d&nbsp;-&nbsp;1&nbsp;)&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;m&nbsp;[|&nbsp;q&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>leverrier_real_char_poly matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;leverrier_real_char_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;t&nbsp;=&nbsp;ref&nbsp;(&nbsp;-.&nbsp;<span class="constructor">Matrix</span>.float_trace&nbsp;m&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;m&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;2&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;uu&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;m&nbsp;!u&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;(<span class="constructor">Matrix</span>.float_trace&nbsp;uu&nbsp;)&nbsp;/.&nbsp;(&nbsp;float&nbsp;(&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;uu&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_float&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_poly_det char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_poly_det&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;-.&nbsp;x&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_resultant_bis characteristic_polynomial_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_resultant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:float&nbsp;array)&nbsp;(q:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;real_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;char_poly_methode&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;real_poly_det&nbsp;pp&nbsp;m&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_discriminant_bis characteristic_polynomial_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_discriminant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;real_resultant_bis&nbsp;char_poly_methode&nbsp;p&nbsp;(&nbsp;poly_real_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_real_inv char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_real_inv&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;(-1.)&nbsp;/.&nbsp;p.(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;poly_real_apply_matrix&nbsp;q&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;x&nbsp;mm&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Coefficientsentiers"><h2>Coefficients entiers</h2></span>
<span id="2_Integercoefficients"><h2>Integer coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_apply_matrix polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_int_apply_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_int_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;r&nbsp;r&nbsp;p.(d)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;m&nbsp;!mm&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;!mm&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;r&nbsp;r&nbsp;p.(i)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!mm&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_int_apply_matrix_rec polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_int_apply_matrix_rec&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_int_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;=&nbsp;3&nbsp;<span class="keyword">then</span>&nbsp;poly_int_apply_matrix&nbsp;p&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;tail&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;head&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;dd&nbsp;(&nbsp;d&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.int_power&nbsp;dd&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mmm&nbsp;=&nbsp;poly_int_apply_matrix_rec&nbsp;head&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;(&nbsp;poly_int_apply_matrix_rec&nbsp;tail&nbsp;m&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;mm&nbsp;mmm&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_companion polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_companion&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_int_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;(-1)&nbsp;/&nbsp;p.(d)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;q.(i)&nbsp;*&nbsp;coeff<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;<span class="constructor">Matrix</span>.identity_int_bis&nbsp;(&nbsp;d&nbsp;-&nbsp;1&nbsp;)&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;m&nbsp;[|&nbsp;q&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>leverrier_int_char_poly matrix</pre> This algorithm may work
despite the use of an euclidean division.
<p>

Cet algorithme peut fonctionner malgré l'utilisation d'une division euclidienne.*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;leverrier_int_char_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;t&nbsp;=&nbsp;ref&nbsp;(&nbsp;-&nbsp;<span class="constructor">Matrix</span>.int_trace&nbsp;m&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;m&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;2&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;uu&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;m&nbsp;!u&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;(<span class="constructor">Matrix</span>.int_trace&nbsp;uu&nbsp;)&nbsp;/&nbsp;(&nbsp;-&nbsp;i&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;uu&nbsp;(&nbsp;<span class="constructor">Matrix</span>.scal_int&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_poly_det char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_poly_det&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;-&nbsp;x&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_resultant_bis characteristic_polynomial_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_resultant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:int&nbsp;array)&nbsp;(q:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;int_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;char_poly_methode&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;int_poly_det&nbsp;pp&nbsp;m&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_discriminant_bis characteristic_polynomial_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_discriminant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:int&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;int_resultant_bis&nbsp;char_poly_methode&nbsp;p&nbsp;(&nbsp;poly_int_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_int_inv char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_int_inv&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;(-1)&nbsp;/&nbsp;p.(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;poly_int_apply_matrix&nbsp;q&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_scal_mult&nbsp;x&nbsp;mm&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Coefficientscomplexes"><h2>Coefficients complexes</h2></span>
<span id="2_Complexcoefficients"><h2>Complex coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_apply_matrix polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_apply_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;ref&nbsp;(&nbsp;scal_complex&nbsp;r&nbsp;r&nbsp;p.(d)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;m&nbsp;!mm&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!mm&nbsp;(&nbsp;scal_complex&nbsp;r&nbsp;r&nbsp;p.(i)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!mm&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_apply_matrix_rec polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_complex_apply_matrix_rec&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;=&nbsp;3&nbsp;<span class="keyword">then</span>&nbsp;poly_complex_apply_matrix&nbsp;p&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;tail&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;head&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;dd&nbsp;(&nbsp;d&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_power&nbsp;dd&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mmm&nbsp;=&nbsp;poly_complex_apply_matrix_rec&nbsp;head&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;(&nbsp;poly_complex_apply_matrix_rec&nbsp;tail&nbsp;m&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;mm&nbsp;mmm&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_companion polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_companion&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;complex_inv&nbsp;p.(d)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;q.(i)&nbsp;coeff<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;[|&nbsp;complex_1&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;real_companion&nbsp;(&nbsp;poly_complex_real_part&nbsp;qq&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;poly_complex_imag_part&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Matrix</span>.null_float&nbsp;(&nbsp;d&nbsp;-&nbsp;1&nbsp;)&nbsp;d&nbsp;)&nbsp;[|&nbsp;qqq&nbsp;|]&nbsp;<span class="keyword">in</span><br>
</code><table><tr><td></td><td><span class="comment">(** Attention : les coefficients du polynôme changent de signe.
Be careful: the signs of the coefficients of the polynomial change. *)</span></td></tr></table><code class="code"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;[|&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;x&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;y&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;y&nbsp;)&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Float_matrix_cons</span>&nbsp;x&nbsp;|]&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_foa_crash&nbsp;(&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Foa_matrix_cons</span>&nbsp;m&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>leverrier_complex_char_poly matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;leverrier_complex_char_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;complex_1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;t&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;(&nbsp;complex_trace&nbsp;m&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;m&nbsp;(&nbsp;scal_complex&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;2&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;uu&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;m&nbsp;!u&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;complex_div&nbsp;(&nbsp;complex_trace&nbsp;uu&nbsp;)&nbsp;(&nbsp;float_to_complex&nbsp;(&nbsp;float&nbsp;(&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;uu&nbsp;(&nbsp;scal_complex&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_poly_det char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_poly_det&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;x&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_resultant_bis characteristic_polynomial_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_resultant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;char_poly_methode&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;complex_poly_det&nbsp;pp&nbsp;m&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_discriminant_bis characteristic_polynomial_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_discriminant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;complex_resultant_bis&nbsp;char_poly_methode&nbsp;p&nbsp;(&nbsp;poly_complex_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_inv char_poly matrix</pre> The the characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_inv&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;(&nbsp;complex_inv&nbsp;p.(0)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;1&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;poly_complex_apply_matrix&nbsp;q&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;matrix_complex_scal_mult&nbsp;x&nbsp;mm&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_CoefficientsentiersdeGauss"><h2>Coefficients entiers de Gauss</h2></span>
<span id="2_Gaussintegercoefficients"><h2>Gauss integer coefficients</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_apply_matrix polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_apply_matrix&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_gauss_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;ref&nbsp;(&nbsp;scal_gauss&nbsp;r&nbsp;r&nbsp;p.(d)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">downto</span>&nbsp;0&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;m&nbsp;!mm&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;!mm&nbsp;(&nbsp;scal_gauss&nbsp;r&nbsp;r&nbsp;p.(i)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!mm&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_apply_matrix_rec polynomial matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;poly_gauss_apply_matrix_rec&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_gauss_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;&lt;=&nbsp;3&nbsp;<span class="keyword">then</span>&nbsp;poly_gauss_apply_matrix&nbsp;p&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;tail&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;dd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;head&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;dd&nbsp;(&nbsp;d&nbsp;-&nbsp;dd&nbsp;+&nbsp;1&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.int_power&nbsp;dd&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mmm&nbsp;=&nbsp;poly_gauss_apply_matrix_rec&nbsp;head&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;(&nbsp;poly_gauss_apply_matrix_rec&nbsp;tail&nbsp;m&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;mm&nbsp;mmm&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_companion polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_companion&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_gauss_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;0&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;gauss_inv&nbsp;p.(d)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;d&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;q.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;q.(i)&nbsp;coeff<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;q&nbsp;[|&nbsp;gauss_1&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;int_companion&nbsp;(&nbsp;poly_gauss_real_part&nbsp;qq&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qqq&nbsp;=&nbsp;poly_gauss_imag_part&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.append&nbsp;(&nbsp;<span class="constructor">Matrix</span>.null_int&nbsp;(&nbsp;d&nbsp;-&nbsp;1&nbsp;)&nbsp;d&nbsp;)&nbsp;[|&nbsp;qqq&nbsp;|]&nbsp;<span class="keyword">in</span><br>
</code><table><tr><td></td><td><span class="comment">(** Attention : les coefficients du polynôme changent de signe.
Be careful: the signs of the coefficients of the polynomial change. *)</span></td></tr></table><code class="code"><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;[|&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;x&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;y&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_opp&nbsp;y&nbsp;)&nbsp;;&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Int_matrix_cons</span>&nbsp;x&nbsp;|]&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_int_demakeup&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_ioa_crash&nbsp;(&nbsp;<span class="constructor">Matrix</span>.<span class="constructor">Ioa_matrix_cons</span>&nbsp;m&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>leverrier_gauss_char_poly matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;leverrier_gauss_char_poly&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;(&nbsp;l&nbsp;+&nbsp;1&nbsp;)&nbsp;gauss_1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;t&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_opp&nbsp;(&nbsp;gauss_trace&nbsp;m&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;m&nbsp;(&nbsp;scal_gauss&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;1&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;2&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;uu&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_prod&nbsp;m&nbsp;!u&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_scal_left_div&nbsp;(&nbsp;-&nbsp;i&nbsp;)&nbsp;(&nbsp;gauss_trace&nbsp;uu&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_int_plus&nbsp;uu&nbsp;(&nbsp;scal_gauss&nbsp;l&nbsp;l&nbsp;!t&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.(&nbsp;l&nbsp;-&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;!t&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_poly_det char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_poly_det&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;p.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;<span class="keyword">mod</span>&nbsp;2&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;<span class="constructor">Matrix</span>.matrix_int_opp&nbsp;x&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_resultant_bis characteristic_polynomial_methode polynomial1 polynomial2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_resultant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(q:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;gauss_sylvester_matrix&nbsp;p&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;char_poly_methode&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;gauss_poly_det&nbsp;pp&nbsp;m&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_discriminant_bis characteristic_polynomial_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_discriminant_bis&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;char_poly_methode&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;gauss_resultant_bis&nbsp;char_poly_methode&nbsp;p&nbsp;(&nbsp;poly_gauss_deriv&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_inv char_poly matrix</pre> The characteristic polynomial must be provided, 
as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

Le polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_inv&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:int&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_opp&nbsp;p.(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;p&nbsp;1&nbsp;(&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;poly_gauss_apply_matrix&nbsp;q&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;matrix_gauss_scal_left_div&nbsp;x&nbsp;mm&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_DcompositiondeJordan"><h2>Décomposition de Jordan</h2></span>
<span id="2_Jordandecomposition"><h2>Jordan decomposition</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sci_jordan_decomposition_polynomial mult_rule comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sci_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;comp_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;s0&nbsp;=&nbsp;poly_sci_x<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;ref&nbsp;s0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;s_old&nbsp;=&nbsp;ref&nbsp;s0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;deg_pp&nbsp;=&nbsp;poly_sci_deg&nbsp;pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dpp&nbsp;=&nbsp;poly_sci_deriv&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;max_iter&nbsp;=&nbsp;(&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;log&nbsp;(&nbsp;(&nbsp;float&nbsp;l&nbsp;)&nbsp;/.&nbsp;deg_pp&nbsp;)&nbsp;)&nbsp;/.&nbsp;(&nbsp;log&nbsp;2.&nbsp;)&nbsp;)&nbsp;)&nbsp;+&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;=&nbsp;max_iter&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p_p&nbsp;=&nbsp;comp_rule&nbsp;dpp&nbsp;!s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;poly_sci_bezout&nbsp;mult_rule&nbsp;p_p&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;z.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;mult_rule&nbsp;u&nbsp;(&nbsp;comp_rule&nbsp;pp&nbsp;!s&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;poly_sci_cleanup&nbsp;(&nbsp;poly_sci_minus&nbsp;!s&nbsp;(&nbsp;poly_sci_mod&nbsp;y&nbsp;p&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;poly_sci_mod&nbsp;x&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;poly_sci_eq&nbsp;!s&nbsp;!s_old&nbsp;<span class="keyword">then</span>&nbsp;i&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!s&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sci_1024_jordan_decomposition_polynomial mult_rule comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sci_1024_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;comp_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;s0&nbsp;=&nbsp;poly_sci_x<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;ref&nbsp;s0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;s_old&nbsp;=&nbsp;ref&nbsp;s0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_1024_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;deg_pp&nbsp;=&nbsp;poly_sci_deg&nbsp;pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dpp&nbsp;=&nbsp;poly_sci_1024_deriv&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;max_iter&nbsp;=&nbsp;(&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;log&nbsp;(&nbsp;(&nbsp;float&nbsp;l&nbsp;)&nbsp;/.&nbsp;deg_pp&nbsp;)&nbsp;)&nbsp;/.&nbsp;(&nbsp;log&nbsp;2.&nbsp;)&nbsp;)&nbsp;)&nbsp;+&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;=&nbsp;max_iter&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p_p&nbsp;=&nbsp;comp_rule&nbsp;dpp&nbsp;!s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;poly_sci_1024_bezout&nbsp;mult_rule&nbsp;p_p&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;z.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;mult_rule&nbsp;u&nbsp;(&nbsp;comp_rule&nbsp;pp&nbsp;!s&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;poly_sci_cleanup&nbsp;(&nbsp;poly_sci_1024_minus&nbsp;!s&nbsp;(&nbsp;poly_sci_1024_mod&nbsp;y&nbsp;p&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;poly_sci_1024_mod&nbsp;x&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;poly_sci_1024_eq&nbsp;!s&nbsp;!s_old&nbsp;<span class="keyword">then</span>&nbsp;i&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!s&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>lento_complex_jordan_decomposition_polynomial sci_mult_rule sci_comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;lento_complex_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;sci_mult_rule&nbsp;sci_comp_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_to_complex&nbsp;(&nbsp;sci_jordan_decomposition_polynomial&nbsp;sci_mult_rule&nbsp;sci_comp_rule&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>lento_real_jordan_decomposition_polynomial sci_mult_rule sci_comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;lento_real_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;sci_mult_rule&nbsp;sci_comp_rule&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_real_part&nbsp;(&nbsp;sci_jordan_decomposition_polynomial&nbsp;sci_mult_rule&nbsp;sci_comp_rule&nbsp;(&nbsp;poly_real_to_sci&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_complex_jordan_decomposition_polynomial sci_mult_rule sci_comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_complex_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;sci_1024_mult_rule&nbsp;sci_1024_comp_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_to_complex&nbsp;(&nbsp;sci_1024_jordan_decomposition_polynomial&nbsp;sci_1024_mult_rule&nbsp;sci_1024_comp_rule&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_real_jordan_decomposition_polynomial sci_mult_rule sci_comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_real_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;sci_1024_mult_rule&nbsp;sci_1024_comp_rule&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_real_part&nbsp;(&nbsp;sci_1024_jordan_decomposition_polynomial&nbsp;sci_1024_mult_rule&nbsp;sci_1024_comp_rule&nbsp;(&nbsp;poly_real_to_sci&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>real_jordan_decomposition_polynomial mult_rule comp_rule polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;real_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;comp_rule&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;128.&nbsp;*.&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;s0&nbsp;=&nbsp;poly_real_x<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;ref&nbsp;s0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;s_old&nbsp;=&nbsp;ref&nbsp;s0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_real_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;deg_pp&nbsp;=&nbsp;poly_real_deg&nbsp;pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dpp&nbsp;=&nbsp;poly_real_deriv&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;max_iter&nbsp;=&nbsp;(&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;log&nbsp;(&nbsp;(&nbsp;float&nbsp;l&nbsp;)&nbsp;/.&nbsp;deg_pp&nbsp;)&nbsp;)&nbsp;/.&nbsp;(&nbsp;log&nbsp;2.&nbsp;)&nbsp;)&nbsp;)&nbsp;+&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;=&nbsp;max_iter&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p_p&nbsp;=&nbsp;comp_rule&nbsp;dpp&nbsp;!s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;poly_real_bezout&nbsp;mult_rule&nbsp;p_p&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;z.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;mult_rule&nbsp;u&nbsp;(&nbsp;comp_rule&nbsp;pp&nbsp;!s&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;poly_real_cleanup&nbsp;(&nbsp;poly_real_minus&nbsp;!s&nbsp;(&nbsp;poly_real_mod&nbsp;y&nbsp;p&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;poly_real_mod&nbsp;x&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_inf&nbsp;(&nbsp;poly_real_minus&nbsp;!s&nbsp;!s_old&nbsp;)&nbsp;&lt;=&nbsp;seuil&nbsp;*.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_1&nbsp;!s_old&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;i&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!s&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_jordan_decomposition_polynomial mult_rule comp_rule polynomial</pre> The computing time seems to be
in <code class="code"><span class="constructor">O</span>(n^4)</code> where <code class="code">n</code> is the order of the matrix when there is no iteration.
When the order is too big, the calculus is erroneous.
The characteristic polynomial must be provided, as for example <code class="code">leverrier_real_char_poly m</code>.
<p>

La méthode de calcul du polynôme caractéristique doit être précisé, comme par exemple <code class="code">leverrier_real_char_poly m</code>.
Il semble que le temps de calcul soit en <code class="code"><span class="constructor">O</span>(n^4)</code> où <code class="code">n</code> est l'ordre de la matrice
quand il n' y a pas d'itération. Quand l'ordre est trop grand, le calcul est erroné. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_jordan_decomposition_polynomial&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;comp_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;-&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;128.&nbsp;*.&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;s0&nbsp;=&nbsp;poly_complex_x<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;ref&nbsp;s0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;s_old&nbsp;=&nbsp;ref&nbsp;s0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_complex_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;deg_pp&nbsp;=&nbsp;poly_complex_deg&nbsp;pp<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;dpp&nbsp;=&nbsp;poly_complex_deriv&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;max_iter&nbsp;=&nbsp;(&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;log&nbsp;(&nbsp;(&nbsp;float&nbsp;l&nbsp;)&nbsp;/.&nbsp;deg_pp&nbsp;)&nbsp;)&nbsp;/.&nbsp;(&nbsp;log&nbsp;2.&nbsp;)&nbsp;)&nbsp;)&nbsp;+&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;=&nbsp;max_iter&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p_p&nbsp;=&nbsp;comp_rule&nbsp;dpp&nbsp;!s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;poly_complex_bezout&nbsp;mult_rule&nbsp;p_p&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;z.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;mult_rule&nbsp;u&nbsp;(&nbsp;comp_rule&nbsp;pp&nbsp;!s&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;poly_complex_cleanup&nbsp;(&nbsp;poly_complex_minus&nbsp;!s&nbsp;(&nbsp;poly_complex_mod&nbsp;y&nbsp;p&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;poly_complex_mod&nbsp;x&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;vector_complex_norm_inf_bis&nbsp;(&nbsp;poly_complex_minus&nbsp;!s&nbsp;!s_old&nbsp;)&nbsp;&lt;=&nbsp;seuil&nbsp;*.&nbsp;(&nbsp;vector_complex_norm_1_bis&nbsp;!s_old&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;i&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;(&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;&nbsp;s_old&nbsp;:=&nbsp;!s&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!s&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>jordan_decomposition apply_rule polynomial matrix</pre> The (real or complex) decomposition polynomial of the matrix must be provided, 
using for example the function <code class="code">lento_complex_jordan_decomposition_polynomial</code>.
The rule of application of a polynomial to a matrix must be provided too.
<p>

Le polynôme de décomposition (réel ou complexe) de la matrice doit être précisé, 
en utilisant par exemple la fonction <code class="code">lento_complex_jordan_decomposition_polynomial</code>.
La loi d'application d'un polynôme à une matrice doit aussi être précisée. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;jordan_decomposition&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;apply_rule&nbsp;p&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;apply_rule&nbsp;p&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;[|&nbsp;d&nbsp;;&nbsp;n&nbsp;|]&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Autresconstructions"><h1>Autres constructions</h1></span>
<span id="1_Furtherconstructions"><h1>Further constructions</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Coefficientsdubinmeetacclrateursdeconvergence"><h2>Coefficients du binôme et accélérateurs de convergence</h2></span>
<span id="2_Binomilacoefficientsandconvergenceaccelerators"><h2>Binoùmila coefficients and convergence accelerators</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>newton_float_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;newton_float_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_real_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;1.&nbsp;;&nbsp;1.&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>alternate_newton_float_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;alternate_newton_float_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_real_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;1.&nbsp;;&nbsp;-1.&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>newton_int_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;newton_int_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_int_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;1&nbsp;;&nbsp;1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>alternate_newton_int_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;alternate_newton_int_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_int_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;1&nbsp;;&nbsp;-1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>newton_complex_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;newton_complex_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_complex_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;complex_1&nbsp;;&nbsp;complex_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>alternate_newton_complex_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;alternate_newton_complex_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_complex_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;complex_1&nbsp;;&nbsp;complex_minus_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>newton_gauss_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;newton_gauss_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_gauss_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;gauss_1&nbsp;;&nbsp;gauss_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>alternate_newton_gauss_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;alternate_newton_gauss_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_gauss_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;gauss_1&nbsp;;&nbsp;gauss_minus_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>newton_sci_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;newton_sci_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>alternate_newton_sci_binom_coeff mult_rule integer</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;alternate_newton_sci_binom_coeff&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_sci_pow&nbsp;mult_rule&nbsp;n&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_minus_1&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>float_euler_transform mult_rule index sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;float_euler_transform&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(seq:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;seq.(0)&nbsp;*.&nbsp;0.5<br>
&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;newton_float_binom_coeff&nbsp;mult_rule&nbsp;n<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.sub&nbsp;seq&nbsp;0&nbsp;(&nbsp;succ&nbsp;n&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;(2.)&nbsp;**&nbsp;(&nbsp;float&nbsp;(&nbsp;-&nbsp;(&nbsp;succ&nbsp;n&nbsp;)&nbsp;)&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_prod&nbsp;v&nbsp;s&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>float_differences sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;float_differences&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(seq:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;length&nbsp;=&nbsp;pred&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;seq&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.mapi&nbsp;(&nbsp;<span class="keyword">fun</span>&nbsp;i&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x&nbsp;-.&nbsp;seq.(i)&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.sub&nbsp;seq&nbsp;1&nbsp;length&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;seq.(0)&nbsp;|]&nbsp;s&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>float_euler_sum_series mult_rule sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;float_euler_sum_series&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(seq:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;seq&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;!accu&nbsp;+.&nbsp;(&nbsp;float_euler_transform&nbsp;mult_rule&nbsp;i&nbsp;seq&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>float_euler_sum_sequence mult_rule sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;float_euler_sum_sequence&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(seq:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;float_differences&nbsp;seq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;float_euler_sum_series&nbsp;mult_rule&nbsp;s&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_euler_transform mult_rule index sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_euler_transform&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(n:int)&nbsp;(seq:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;0.5&nbsp;seq.(0)<br>
&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;complex_poly_to_complex_double_vector&nbsp;(&nbsp;newton_complex_binom_coeff&nbsp;mult_rule&nbsp;n&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;complex_poly_to_complex_double_vector&nbsp;(&nbsp;<span class="constructor">Array</span>.sub&nbsp;seq&nbsp;0&nbsp;(&nbsp;succ&nbsp;n&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;(&nbsp;(2.)&nbsp;**&nbsp;(&nbsp;float&nbsp;(&nbsp;-&nbsp;(&nbsp;succ&nbsp;n&nbsp;)&nbsp;)&nbsp;)&nbsp;)&nbsp;(&nbsp;vector_complex_hermitian_prod&nbsp;v&nbsp;s&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_differences sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_differences&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(seq:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;length&nbsp;=&nbsp;pred&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;seq&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.mapi&nbsp;(&nbsp;<span class="keyword">fun</span>&nbsp;i&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;x&nbsp;seq.(i)&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.sub&nbsp;seq&nbsp;1&nbsp;length&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;seq.(0)&nbsp;|]&nbsp;s&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_euler_sum_series mult_rule sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_euler_sum_series&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(seq:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;seq&nbsp;)&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu&nbsp;(&nbsp;complex_euler_transform&nbsp;mult_rule&nbsp;i&nbsp;seq&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_euler_sum_sequence mult_rule sequence</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_euler_sum_sequence&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;(seq:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_differences&nbsp;seq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;complex_euler_sum_series&nbsp;mult_rule&nbsp;s&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Gnrateursalatoires"><h2>Générateurs aléatoires</h2></span>
<span id="2_Randomgenerators"><h2>Random generators</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_random rows columns range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(c:int)&nbsp;(w:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_bal_random&nbsp;r&nbsp;c&nbsp;w<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_bal_random&nbsp;r&nbsp;c&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_random range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_random&nbsp;=&nbsp;<span class="keyword">function</span>(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;matrix_complex_random&nbsp;1&nbsp;1&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_random degree range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(d:int)&nbsp;(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_bal_random&nbsp;(&nbsp;2&nbsp;*&nbsp;(&nbsp;d&nbsp;+&nbsp;1&nbsp;)&nbsp;)&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_unitary_random degree range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_unitary_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(d:int)&nbsp;(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;poly_complex_random&nbsp;(&nbsp;pred&nbsp;d&nbsp;)&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;[|&nbsp;complex_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_herm_random order range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_herm_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sym_float_bal_random&nbsp;r&nbsp;x<br>
&nbsp;<span class="keyword">and</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Matrix</span>.antisym_float_bal_random&nbsp;r&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;s&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_complex_anti_herm_random order range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_complex_anti_herm_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sym_float_bal_random&nbsp;r&nbsp;x<br>
&nbsp;<span class="keyword">and</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Matrix</span>.antisym_float_bal_random&nbsp;r&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_complexify&nbsp;a&nbsp;s&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_unitary_random order range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_unitary_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(x:float)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;matrix_complex_anti_herm_random&nbsp;r&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Matrix</span>.generic_ortho_float_antisym&nbsp;a&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_random rows columns range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(c:int)&nbsp;(w:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_bal_random&nbsp;r&nbsp;c&nbsp;w<br>
&nbsp;<span class="keyword">and</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_int_bal_random&nbsp;r&nbsp;c&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_gauss_complexify&nbsp;x&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_random range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_random&nbsp;=&nbsp;<span class="keyword">function</span>(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;matrix_gauss_random&nbsp;1&nbsp;1&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_random degree range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(d:int)&nbsp;(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_int_bal_random&nbsp;(&nbsp;2&nbsp;*&nbsp;(&nbsp;d&nbsp;+&nbsp;1&nbsp;)&nbsp;)&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;gauss_vector_to_gauss_poly&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_gauss_unitary_random degree range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_gauss_unitary_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(d:int)&nbsp;(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;poly_gauss_random&nbsp;(&nbsp;pred&nbsp;d&nbsp;)&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;p&nbsp;[|&nbsp;gauss_1&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_herm_random order range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_herm_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sym_int_bal_random&nbsp;r&nbsp;x<br>
&nbsp;<span class="keyword">and</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Matrix</span>.antisym_int_bal_random&nbsp;r&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_gauss_complexify&nbsp;s&nbsp;a&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>matrix_gauss_anti_herm_random order range</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;matrix_gauss_anti_herm_random&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(r:int)&nbsp;(x:int)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Matrix</span>.sym_int_bal_random&nbsp;r&nbsp;x<br>
&nbsp;<span class="keyword">and</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Matrix</span>.antisym_int_bal_random&nbsp;r&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;matrix_gauss_complexify&nbsp;a&nbsp;s&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Rductiondesmatricesetracinesdespolynmes"><h1>Réduction des matrices et racines des polynômes</h1></span>
<span id="1_Reductionofmatricesandrootsofpolynomials"><h1>Reduction of matrices and roots of polynomials</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_diago_spectrum diagonalization_methode matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_diago_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(diagonalization_methode:float&nbsp;array&nbsp;array&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;float&nbsp;array&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;diagonalization_methode&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;w.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_householder_step threshold index matrix</pre> Output: transformation matrix, coefficient.
<p>

Sortie : matrice de transformation, coefficient. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_householder_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:float)&nbsp;(i:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;matrix_complex_extract_column_to_matrix_trans&nbsp;i&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;coeff&nbsp;=&nbsp;matrix_complex_extract_coefficient&nbsp;i&nbsp;i&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;r&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;xx&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_copy&nbsp;x<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;argument&nbsp;=&nbsp;apply_built_in_complex_float_to_matrix&nbsp;<span class="constructor">Complex</span>.arg&nbsp;coeff&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;first_row&nbsp;=&nbsp;xx.(0)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;second_row&nbsp;=&nbsp;xx.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;i&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;jj&nbsp;=&nbsp;rr&nbsp;+&nbsp;j&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(j)&nbsp;&lt;-&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_row.(jj)&nbsp;&lt;-&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(j)&nbsp;&lt;-&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second_row.(jj)&nbsp;&lt;-&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;norm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;xx.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;norm&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.identity_float&nbsp;r&nbsp;c&nbsp;;&nbsp;complex_0&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_copy&nbsp;xx<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ii&nbsp;=&nbsp;i&nbsp;+&nbsp;rr&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;alpha&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;(&nbsp;-.&nbsp;norm&nbsp;)&nbsp;(&nbsp;polar_to_matrix&nbsp;1.&nbsp;argument&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;fr&nbsp;=&nbsp;u.(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;sr&nbsp;=&nbsp;u.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a00&nbsp;=&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;alpha.(0).(0)&nbsp;+.&nbsp;alpha.(1).(1)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;b01&nbsp;=&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;alpha.(0).(1)&nbsp;-.&nbsp;alpha.(1).(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;c10&nbsp;=&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;alpha.(1).(0)&nbsp;-.&nbsp;alpha.(0).(1)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;d11&nbsp;=&nbsp;0.5&nbsp;*.&nbsp;(&nbsp;alpha.(1).(1)&nbsp;+.&nbsp;alpha.(0).(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.(i)&nbsp;&lt;-&nbsp;fr.(i)&nbsp;+.&nbsp;a00&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.(ii)&nbsp;&lt;-&nbsp;fr.(ii)&nbsp;+.&nbsp;b01&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sr.(i)&nbsp;&lt;-&nbsp;sr.(i)&nbsp;+.&nbsp;c10&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sr.(ii)&nbsp;&lt;-&nbsp;sr.(ii)&nbsp;+.&nbsp;d11&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;length&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;fr&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_left_div&nbsp;length&nbsp;u&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w1&nbsp;=&nbsp;vector_complex_hermitian_prod&nbsp;v&nbsp;x<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;w2&nbsp;=&nbsp;vector_complex_hermitian_prod&nbsp;x&nbsp;v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;(&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;w2&nbsp;&lt;&gt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;w1&nbsp;(&nbsp;complex_inv&nbsp;w2&nbsp;)&nbsp;<span class="keyword">else</span>&nbsp;complex_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.(0).(0)&nbsp;&lt;-&nbsp;w.(0).(0)&nbsp;+.&nbsp;1.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.(1).(1)&nbsp;&lt;-&nbsp;w.(1).(1)&nbsp;+.&nbsp;1.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ww&nbsp;=&nbsp;matrix_complex_scal_mult&nbsp;w&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;vv&nbsp;vv&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;(&nbsp;<span class="constructor">Matrix</span>.identity_float&nbsp;r&nbsp;c&nbsp;)&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;q&nbsp;;&nbsp;alpha&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_qr_decomposition threshold matrix</pre> Output: unitary transformation matrix <code class="code">q</code> and complex upper triangular matrix <code class="code">r</code> such that <code class="code">m = qr</code>, transposed transformation matrix.
<p>

Sortie : matrice de transformation unitaire <code class="code">q</code>, matrice triangulaire supérieure complexe <code class="code">r</code> telles que <code class="code">m = qr</code>, transposée de la matrice de transformation. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_qr_decomposition&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:float)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;min&nbsp;r&nbsp;c&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.identity_float&nbsp;r&nbsp;c&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;rr&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_copy&nbsp;m&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;-&nbsp;2&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;complex_householder_step&nbsp;threshold&nbsp;i&nbsp;!rr&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rr&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(0)&nbsp;!rr&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(0)&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;!qq&nbsp;;&nbsp;!rr&nbsp;;&nbsp;!qq&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_francis_iteration threshold_qr threshold max_steps threshold matrix</pre> Output: candidate for the upper trigonality, 
unitary transformation matrix <code class="code">q</code>, transposed transformation matrix, measure of the under diagonal part.
<p>

Sortie : candidat pour la trigonalité supérieure, matrice de transformation unitaire <code class="code">q</code>, transposée de la matrice de transformation, mesure de la partie sous-diagonale. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_francis_iteration&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;c&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m.(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;res&nbsp;=&nbsp;complex_qr_decomposition&nbsp;threshold_qr&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;min&nbsp;r&nbsp;c&nbsp;)&nbsp;/&nbsp;2&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;res.(0)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;res.(2)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;threshold&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;candidate&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;res.(1)&nbsp;!q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!i&nbsp;&lt;=&nbsp;steps&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!error&nbsp;&gt;=&nbsp;threshold&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;complex_qr_decomposition&nbsp;threshold_qr&nbsp;!candidate&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidate&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(1)&nbsp;result.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(2)&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!q&nbsp;result.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;row&nbsp;=&nbsp;matrix_complex_extract_row_to_poly&nbsp;j&nbsp;!candidate&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;!error&nbsp;+.&nbsp;(&nbsp;vector_complex_norm_2&nbsp;(&nbsp;<span class="constructor">Array</span>.sub&nbsp;row&nbsp;0&nbsp;j&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!candidate&nbsp;;&nbsp;!q&nbsp;;&nbsp;!qq&nbsp;;&nbsp;[|[|&nbsp;!error&nbsp;|]|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_francis_shifted_step threshold shift matrix</pre> Output: candidate for the tridiagonality, 
left unitary transformation matrix, transpose of the transformation matrix. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_francis_shifted_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;r&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sc&nbsp;=&nbsp;scal_complex&nbsp;nn&nbsp;nn&nbsp;shift&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;sc&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;complex_qr_decomposition&nbsp;threshold&nbsp;mm&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;product&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(1)&nbsp;result.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;sc&nbsp;product&nbsp;;&nbsp;result.(0)&nbsp;;&nbsp;result.(2)&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_francis_shifted_iteration threshold_qr threshold max_steps shift matrix</pre> Output: candidate for the upper trigonality, 
unitary transformation matrix <code class="code">q</code>, transposed transformation matrix, measure of the under diagonal part.
<p>

Sortie : candidat pour la trigonalité supérieure, matrice de transformation unitaire <code class="code">q</code>, transposée de la matrice de transformation, mesure de la partie sous-diagonale. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_francis_shifted_iteration&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_step&nbsp;threshold_qr&nbsp;shift&nbsp;m&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;threshold&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;r&nbsp;/&nbsp;2&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;candidate&nbsp;=&nbsp;ref&nbsp;!res.(0)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;!res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;!res.(2)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!i&nbsp;&lt;=&nbsp;steps&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!error&nbsp;&gt;=&nbsp;threshold&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;complex_francis_shifted_step&nbsp;threshold_qr&nbsp;shift&nbsp;!candidate&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidate&nbsp;:=&nbsp;result.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(2)&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!q&nbsp;result.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;0.&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;row&nbsp;=&nbsp;matrix_complex_extract_row_to_poly&nbsp;j&nbsp;!candidate&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;!error&nbsp;+.&nbsp;(&nbsp;vector_complex_norm_2&nbsp;(&nbsp;<span class="constructor">Array</span>.sub&nbsp;row&nbsp;0&nbsp;j&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!candidate&nbsp;;&nbsp;!q&nbsp;;&nbsp;!qq&nbsp;;&nbsp;[|[|&nbsp;!error&nbsp;|]|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_francis_schur_decomposition threshold_qr threshold max_steps matrix</pre> Output: candidate for the upper trigonality, 
unitary transformation matrix <code class="code">q</code>, transposed transformation matrix, measure of the under diagonal part.
<p>

Sortie : candidat pour la trigonalité supérieure, matrice de transformation unitaire <code class="code">q</code>, transposée de la matrice de transformation, mesure de la partie sous-diagonale. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_francis_schur_decomposition&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;old_res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;0&nbsp;m&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;0&nbsp;!old_res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_q&nbsp;=&nbsp;ref&nbsp;!old_res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_qq&nbsp;=&nbsp;ref&nbsp;!old_res.(2)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!old_q&nbsp;!res.(1)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!res.(2)&nbsp;!old_qq&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!i&nbsp;&lt;=&nbsp;steps&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_res&nbsp;:=&nbsp;!res&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;0&nbsp;!old_res.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_q&nbsp;:=&nbsp;!q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_qq&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!old_q&nbsp;!res.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!res.(2)&nbsp;!old_qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!res.(0)&nbsp;;&nbsp;!q&nbsp;;&nbsp;!qq&nbsp;;&nbsp;!res.(3)&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;[|&nbsp;!old_res.(0)&nbsp;;&nbsp;!old_q&nbsp;;&nbsp;!old_qq&nbsp;;&nbsp;!old_res.(3)&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_shifted_francis_schur_decomposition threshold_qr threshold max_steps shift matrix</pre> Output: candidate for the upper trigonality, 
unitary transformation matrix <code class="code">q</code>, transposed transformation matrix, measure of the under diagonal part.
<p>

Sortie : candidat pour la trigonalité supérieure, matrice de transformation unitaire <code class="code">q</code>, transposée de la matrice de transformation, mesure de la partie sous-diagonale. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_shifted_francis_schur_decomposition&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;old_res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;0&nbsp;shift&nbsp;m&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;0&nbsp;shift&nbsp;!old_res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_q&nbsp;=&nbsp;ref&nbsp;!old_res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_qq&nbsp;=&nbsp;ref&nbsp;!old_res.(2)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!old_q&nbsp;!res.(1)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;qq&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!res.(2)&nbsp;!old_qq&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!i&nbsp;&lt;=&nbsp;steps&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_res&nbsp;:=&nbsp;!res&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;0&nbsp;shift&nbsp;!old_res.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_q&nbsp;:=&nbsp;!q&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_qq&nbsp;:=&nbsp;!qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!old_q&nbsp;!res.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qq&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;!res.(2)&nbsp;!old_qq&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;!res.(0)&nbsp;;&nbsp;!q&nbsp;;&nbsp;!qq&nbsp;;&nbsp;!res.(3)&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;[|&nbsp;!old_res.(0)&nbsp;;&nbsp;!old_q&nbsp;;&nbsp;!old_qq&nbsp;;&nbsp;!old_res.(3)&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_francis_spectrum threshold_qr threshold max_steps matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_francis_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;matrix_unitary_random&nbsp;r&nbsp;1.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;old_res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;w&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;!old_res.(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!i&nbsp;&lt;&nbsp;steps&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_res&nbsp;:=&nbsp;!res&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;!old_res.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!res.(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!old_res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_shifted_francis_spectrum threshold_qr threshold max_steps shift matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_shifted_francis_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;matrix_unitary_random&nbsp;r&nbsp;1.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;old_res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;shift&nbsp;w&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;shift&nbsp;!old_res.(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!i&nbsp;&lt;&nbsp;steps&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_res&nbsp;:=&nbsp;!res&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;shift&nbsp;!old_res.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!res.(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!old_res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_francis_spectrum_seq threshold_qr threshold max_steps matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_francis_spectrum_seq&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;matrix_unitary_random&nbsp;r&nbsp;1.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;old_res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;w&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;!old_res.(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;seq&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_poly_to_complex_vector&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!old_res.(0)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complex_poly_to_complex_vector&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!res.(0)&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!i&nbsp;&lt;&nbsp;pred&nbsp;steps&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_res&nbsp;:=&nbsp;!res&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;complex_francis_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;!old_res.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!seq&nbsp;[|&nbsp;complex_poly_to_complex_vector&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!res.(0)&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!res.(3).(0).(0)&nbsp;&gt;=&nbsp;!old_res.(3).(0).(0)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;:=&nbsp;<span class="constructor">Array</span>.sub&nbsp;!seq&nbsp;0&nbsp;(&nbsp;pred&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!seq&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!seq&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_shifted_francis_spectrum_seq threshold_qr threshold max_steps shift matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_shifted_francis_spectrum_seq&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;m&nbsp;)&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;matrix_unitary_random&nbsp;r&nbsp;1.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;old_res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;shift&nbsp;w&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;shift&nbsp;!old_res.(0)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;seq&nbsp;=&nbsp;ref&nbsp;[|&nbsp;complex_poly_to_complex_vector&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!old_res.(0)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complex_poly_to_complex_vector&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!res.(0)&nbsp;)&nbsp;|]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(&nbsp;!res.(3).(0).(0)&nbsp;&lt;&nbsp;!old_res.(3).(0).(0)&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;!i&nbsp;&lt;&nbsp;pred&nbsp;steps&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_res&nbsp;:=&nbsp;!res&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;complex_francis_shifted_iteration&nbsp;threshold_qr&nbsp;threshold&nbsp;1&nbsp;shift&nbsp;!old_res.(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!seq&nbsp;[|&nbsp;complex_poly_to_complex_vector&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;!res.(0)&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!res.(3).(0).(0)&nbsp;&gt;=&nbsp;!old_res.(3).(0).(0)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;:=&nbsp;<span class="constructor">Array</span>.sub&nbsp;!seq&nbsp;0&nbsp;(&nbsp;pred&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!seq&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!seq&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_compensated_francis_spectrum accelerator threshold_qr threshold max_steps matrix</pre> A convergence accelerator for real vector sequences
must be provided, like for instance <code class="code"><span class="constructor">Matrix</span>.vector_float_approx_bis</code>.
<p>

Il faut fournir un accélérateur de convergence de suites de vecteurs réels, comme par exemple <code class="code"><span class="constructor">Matrix</span>.vector_float_approx_bis</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_compensated_francis_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accel&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_francis_spectrum_seq&nbsp;threshold_qr&nbsp;threshold&nbsp;steps&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limit&nbsp;=&nbsp;accel&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;limit&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_compensated_shifted_francis_spectrum accelerator threshold_qr threshold max_steps shift matrix</pre> A convergence accelerator for real vector sequences
must be provided, like for instance <code class="code"><span class="constructor">Matrix</span>.vector_float_approx_bis</code>.
<p>

Il faut fournir un accélérateur de convergence de suites de vecteurs réels, comme par exemple <code class="code"><span class="constructor">Matrix</span>.vector_float_approx_bis</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_compensated_shifted_francis_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accel&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_shifted_francis_spectrum_seq&nbsp;threshold_qr&nbsp;threshold&nbsp;steps&nbsp;shift&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limit&nbsp;=&nbsp;accel&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;limit&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_diagonalization methode_ker threshold_qr threshold steps_qr steps_power matrix</pre> The matrix is supposed to be diagonalizable.
The first number of steps <code class="code">steps_qr</code> is the one used in
the QR algorithm of Francis ; the second <code class="code">steps</code> is the one used in the inverse iteration.
The method <code class="code">methode_ker</code> may be the one used to search for a kernel with the singular value decomposition.
In the case when the matrix is not simple, the passage matrix has few precision.
Output: spectrum, matrix whose columns are the respective eigenvectors, matrix whose rows are the respective eigenvectors.
<p>

Sortie : spectre, matrice dont les colonnes sont les vecteurs propres correspondants, matrice dont les lignes sont les vecteurs propores correspondants.
La matrice est supposée diagonalisable.
Le premier nombre maximal de pas <code class="code">steps_qr</code> est celui utilisé pour l'algorithme QR de Francis ;
le deuxième <code class="code">steps</code> est celui utilisé dans l'itération inverse.
La méthode <code class="code">methode_ker</code> peut être celle utilisée pour rechercher un noyau avec la décomposition en valeurs singulières.
Dans le cas où la matrice n'est pas simple, la matrice de passage est peu précise. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_diagonalization&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;complex_francis_schur_decomposition&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;sqrt&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_integer&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_complex&nbsp;=&nbsp;ref&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;clean_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;nn&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;spectrum&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;complex_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n_n&nbsp;=&nbsp;n&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;trans_passage&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;nn&nbsp;nn&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;candidate_value&nbsp;=&nbsp;p.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;difference&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;scal_complex&nbsp;n&nbsp;n&nbsp;candidate_value&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_invertibility&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_normalized_iterate&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;steps&nbsp;mm&nbsp;q.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(&nbsp;n&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;vector_complex_i_times&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ww&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;mm&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;z&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;divisor&nbsp;=&nbsp;z.(j)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;divisor&nbsp;&gt;&nbsp;seuil&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;zz.(j)&nbsp;(&nbsp;complex_inv&nbsp;divisor&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;succ&nbsp;!accu_integer&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_left_div&nbsp;(&nbsp;float&nbsp;!accu_integer&nbsp;)&nbsp;!accu_complex&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;candidate_value&nbsp;(&nbsp;complex_inv&nbsp;coeff&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;candidate_value&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;methode_ker&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;kk&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;k&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_bal_random&nbsp;kk&nbsp;10.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w_w&nbsp;=&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;(&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;k&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;(&nbsp;1.&nbsp;/.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;v&nbsp;)&nbsp;)&nbsp;v&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w_coeff&nbsp;=&nbsp;1.&nbsp;/.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;w_w&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;w_coeff&nbsp;w_w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(&nbsp;n&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;vector_complex_i_times&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;spectrum&nbsp;;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;trans_passage&nbsp;|]&nbsp;;&nbsp;[|&nbsp;trans_passage&nbsp;&nbsp;|]&nbsp;|]&nbsp;;;&nbsp;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_shifted_diagonalization methode_ker threshold_qr threshold steps_qr steps_power shift matrix</pre> The matrix is supposed to be diagonalizable.
The first number of steps <code class="code">steps_qr</code> is the one used in
the QR algorithm of Francis ; the second <code class="code">steps</code> is the one used in the inverse iteration.
The method <code class="code">methode_ker</code> may be the one used to search for a kernel with the singular value decomposition.
In the case when the matrix is not simple, the passage matrix has few precision.
Output: spectrum, matrix whose columns are the respective eigenvectors, matrix whose rows are the respective eigenvectors.
<p>

Sortie : spectre, matrice dont les colonnes sont les vecteurs propres correspondants, matrice dont les lignes sont les vecteurs propores correspondants.
La matrice est supposée diagonalisable.
Le premier nombre maximal de pas <code class="code">steps_qr</code> est celui utilisé pour l'algorithme QR de Francis ;
le deuxième <code class="code">steps</code> est celui utilisé dans l'itération inverse.
La méthode <code class="code">methode_ker</code> peut être celle utilisée pour rechercher un noyau avec la décomposition en valeurs singulières.
Dans le cas où la matrice n'est pas simple, la matrice de passage est peu précise. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_shifted_diagonalization&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;complex_shifted_francis_schur_decomposition&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;shift&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;sqrt&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_integer&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_complex&nbsp;=&nbsp;ref&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;clean_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;nn&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;spectrum&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;complex_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n_n&nbsp;=&nbsp;n&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;trans_passage&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;nn&nbsp;nn&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;candidate_value&nbsp;=&nbsp;p.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;difference&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;scal_complex&nbsp;n&nbsp;n&nbsp;candidate_value&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_invertibility&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_normalized_iterate&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;steps&nbsp;mm&nbsp;q.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(&nbsp;n&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;vector_complex_i_times&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ww&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;mm&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;z&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;divisor&nbsp;=&nbsp;z.(j)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;divisor&nbsp;&gt;&nbsp;seuil&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;zz.(j)&nbsp;(&nbsp;complex_inv&nbsp;divisor&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;succ&nbsp;!accu_integer&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_left_div&nbsp;(&nbsp;float&nbsp;!accu_integer&nbsp;)&nbsp;!accu_complex&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;candidate_value&nbsp;(&nbsp;complex_inv&nbsp;coeff&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;candidate_value&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;methode_ker&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;kk&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;k&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_bal_random&nbsp;kk&nbsp;10.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w_w&nbsp;=&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;(&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;k&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;(&nbsp;1.&nbsp;/.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;v&nbsp;)&nbsp;)&nbsp;v&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w_coeff&nbsp;=&nbsp;1.&nbsp;/.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;w_w&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;w_coeff&nbsp;w_w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(&nbsp;n&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;vector_complex_i_times&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;spectrum&nbsp;;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;trans_passage&nbsp;|]&nbsp;;&nbsp;[|&nbsp;trans_passage&nbsp;&nbsp;|]&nbsp;|]&nbsp;;;&nbsp;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_spectrum threshold_qr threshold steps_qr steps matrix</pre> The first number of steps <code class="code">steps_qr</code> 
is the one used in the QR algorithm of Francis ; the second number <code class="code">steps</code> is the one used in the inverse iteration
The matrix is supposed to be diagonalizable.
<p>

La matrice est supposée diagonalisable.
Le premier nombre maximal de pas <code class="code">steps_qr</code> est celui utilisé pour l'algorithme QR de Francis ;
le deuxième <code class="code">steps</code> est celui utilisé dans l'itération inverse.
 *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;complex_francis_schur_decomposition&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;sqrt&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_integer&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_complex&nbsp;=&nbsp;ref&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;clean_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;nn&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;spectrum&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;complex_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n_n&nbsp;=&nbsp;n&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;candidate_value&nbsp;=&nbsp;p.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;difference&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;scal_complex&nbsp;n&nbsp;n&nbsp;candidate_value&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_invertibility&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_normalized_iterate&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;steps&nbsp;mm&nbsp;q.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ww&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;mm&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;z&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;divisor&nbsp;=&nbsp;z.(j)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;divisor&nbsp;&gt;&nbsp;seuil&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;zz.(j)&nbsp;(&nbsp;complex_inv&nbsp;divisor&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;succ&nbsp;!accu_integer&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_left_div&nbsp;(&nbsp;float&nbsp;!accu_integer&nbsp;)&nbsp;!accu_complex&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;candidate_value&nbsp;(&nbsp;complex_inv&nbsp;coeff&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;candidate_value&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;spectrum&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_shifted_spectrum threshold_qr threshold steps_qr steps shift matrix</pre> The first number of steps <code class="code">steps_qr</code> 
is the one used in the QR algorithm of Francis ; the second number <code class="code">steps</code> is the one used in the inverse iteration
The matrix is supposed to be diagonalizable.
<p>

La matrice est supposée diagonalisable.
Le premier nombre maximal de pas <code class="code">steps_qr</code> est celui utilisé pour l'algorithme QR de Francis ;
le deuxième <code class="code">steps</code> est celui utilisé dans l'itération inverse.
 *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_shifted_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;complex_shifted_francis_schur_decomposition&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;shift&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;sqrt&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_integer&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_complex&nbsp;=&nbsp;ref&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;clean_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;nn&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;spectrum&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;complex_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n_n&nbsp;=&nbsp;n&nbsp;-&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;candidate_value&nbsp;=&nbsp;p.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;difference&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;scal_complex&nbsp;n&nbsp;n&nbsp;candidate_value&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_invertibility&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_normalized_iterate&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;steps&nbsp;mm&nbsp;q.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ww&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;mm&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;z&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;divisor&nbsp;=&nbsp;z.(j)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;divisor&nbsp;&gt;&nbsp;seuil&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;zz.(j)&nbsp;(&nbsp;complex_inv&nbsp;divisor&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;succ&nbsp;!accu_integer&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_left_div&nbsp;(&nbsp;float&nbsp;!accu_integer&nbsp;)&nbsp;!accu_complex&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;candidate_value&nbsp;(&nbsp;complex_inv&nbsp;coeff&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;candidate_value&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;spectrum&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_tune_diagonalization factor methode_diag matrix passage_candidate</pre>
This function may be unstable.
The matrix is supposed to be diagonalizable.
The output is the same as for <code class="code">direct_complex_diagonalization</code>.
<p>

La sortie est la même que pour <code class="code">direct_complex_diagonalization</code>.
La matrice est supposée diagonalisable.
Cette fonction peut être instable. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_tune_diagonalization&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(factor:float)&nbsp;methode_diag&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;/&nbsp;2<br>
&nbsp;<span class="keyword">and</span>&nbsp;p_r&nbsp;=&nbsp;matrix_complex_real_part&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;p_i&nbsp;=&nbsp;matrix_complex_imag_part&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;y&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Matrix</span>.matrix_float_bal_random&nbsp;n&nbsp;n&nbsp;y<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;x&nbsp;=&nbsp;factor&nbsp;*.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_norm_inf&nbsp;p&nbsp;)&nbsp;/.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;f&nbsp;x<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;f&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pa&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;p_r&nbsp;a<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;pb&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;p_i&nbsp;b&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;aa&nbsp;=&nbsp;matrix_real_to_complex&nbsp;pa<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;bb&nbsp;=&nbsp;matrix_imag_to_complex&nbsp;pb&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;aa&nbsp;bb&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_triple_prod&nbsp;q&nbsp;m&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;methode_diag&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>indirect_complex_diagonalization factor methode_ker threshold_qr threshold steps_qr steps_power matrix</pre>
The results are often worse than with the function <code class="code">direct_complex_diagonalization</code>
but may be enhanced sometimes by playing with the parameters.
This function may be unstable.
The matrix is supposed to be diagonalizable.
The output is the same as for <code class="code">direct_complex_diagonalization</code>.
<p>

La sortie est la même que pour <code class="code">direct_complex_diagonalization</code>.
La matrice est supposée diagonalisable.
Les résultats sont parfois moins bons qu'avec la fonction <code class="code">direct_complex_diagonalization</code>
mais peuvent être améliorés parfois en jouant sur les paramètres.
Cette fonction peut être instable. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;indirect_complex_diagonalization&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(factor:float)&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;direct_complex_diagonalization&nbsp;methode_ker&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;res.(1).(0)&nbsp;<span class="keyword">and</span>&nbsp;tp&nbsp;=&nbsp;res.(2).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;complex_tune_diagonalization&nbsp;factor&nbsp;(&nbsp;direct_complex_diagonalization&nbsp;methode_ker&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;)&nbsp;m&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;new_p&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;p&nbsp;result.(1).(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;new_tp&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(2).(0)&nbsp;tp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;result.(0)&nbsp;;&nbsp;[|&nbsp;new_p&nbsp;|]&nbsp;;&nbsp;[|&nbsp;new_tp&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>indirect_complex_shifted_diagonalization factor methode_ker threshold_qr threshold steps_qr steps_power shift matrix</pre>
The results are often worse than with the function <code class="code">direct_complex_diagonalization</code>
but may be enhanced sometimes by playing with the parameters.
This function may be unstable.
The matrix is supposed to be diagonalizable.
The output is the same as for <code class="code">direct_complex_diagonalization</code>.
<p>

La sortie est la même que pour <code class="code">direct_complex_diagonalization</code>.
La matrice est supposée diagonalisable.
Les résultats sont parfois moins bons qu'avec la fonction <code class="code">direct_complex_diagonalization</code>
mais peuvent être améliorés parfois en jouant sur les paramètres.
Cette fonction peut être instable. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;indirect_complex_shifted_diagonalization&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(factor:float)&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;direct_complex_shifted_diagonalization&nbsp;methode_ker&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;shift&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;res.(1).(0)&nbsp;<span class="keyword">and</span>&nbsp;tp&nbsp;=&nbsp;res.(2).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;complex_tune_diagonalization&nbsp;factor&nbsp;(&nbsp;direct_complex_shifted_diagonalization&nbsp;methode_ker&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;shift&nbsp;)&nbsp;m&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;new_p&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;p&nbsp;result.(1).(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;new_tp&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;result.(2).(0)&nbsp;tp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;result.(0)&nbsp;;&nbsp;[|&nbsp;new_p&nbsp;|]&nbsp;;&nbsp;[|&nbsp;new_tp&nbsp;|]&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_compensated_spectrum accelerator stages factor methode_ker threshold_qr threshold steps_qr steps matrix</pre> 
The <code class="code">accelerator</code> is appied to real vectors. The <code class="code">factor</code> must be chosen 0 and 1.
<p>

L'accélérateur <code class="code">accelerator</code> s'applique aux vecteurs réels. Le facteur <code class="code">factor</code> doit être choisi entre 0 et 1. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_compensated_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accelerator&nbsp;(stages:int)&nbsp;(factor:float)&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;factor&nbsp;**&nbsp;(&nbsp;float&nbsp;p&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;stages&nbsp;1&nbsp;complex_0<br>
&nbsp;<span class="keyword">and</span>&nbsp;etapes&nbsp;=&nbsp;pred&nbsp;stages&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;etapes&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;s.(i)&nbsp;&lt;-&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;(&nbsp;f&nbsp;steps&nbsp;(&nbsp;etapes&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;s.(etapes)&nbsp;&lt;-&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sequence&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_poly_to_complex_vector&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limit&nbsp;=&nbsp;accelerator&nbsp;sequence&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;limit&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_compensated_shifted_spectrum accelerator stages factor methode_ker threshold_qr threshold steps_qr steps shift matrix</pre> 
The <code class="code">accelerator</code> is appied to real vectors. The <code class="code">factor</code> must be chosen 0 and 1.
<p>

L'accélérateur <code class="code">accelerator</code> s'applique aux vecteurs réels. Le facteur <code class="code">factor</code> doit être choisi entre 0 et 1. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_compensated_shifted_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accelerator&nbsp;(stages:int)&nbsp;(factor:float)&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;factor&nbsp;**&nbsp;(&nbsp;float&nbsp;p&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;stages&nbsp;1&nbsp;complex_0<br>
&nbsp;<span class="keyword">and</span>&nbsp;etapes&nbsp;=&nbsp;pred&nbsp;stages&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;etapes&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;s.(i)&nbsp;&lt;-&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;(&nbsp;f&nbsp;steps&nbsp;(&nbsp;etapes&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;shift&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;s.(etapes)&nbsp;&lt;-&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;shift&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sequence&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_poly_to_complex_vector&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limit&nbsp;=&nbsp;accelerator&nbsp;sequence&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;limit&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_compensated_spectrum accelerator stages factor threshold_qr threshold steps_qr steps matrix</pre> 
The <code class="code">accelerator</code> is appied to real vectors. The <code class="code">factor</code> must be chosen 0 and 1.
<p>

L'accélérateur <code class="code">accelerator</code> s'applique aux vecteurs réels. Le facteur <code class="code">factor</code> doit être choisi entre 0 et 1. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_compensated_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accelerator&nbsp;(stages:int)&nbsp;(factor:float)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;factor&nbsp;**&nbsp;(&nbsp;float&nbsp;p&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;stages&nbsp;1&nbsp;complex_0<br>
&nbsp;<span class="keyword">and</span>&nbsp;etapes&nbsp;=&nbsp;pred&nbsp;stages&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;etapes&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;s.(i)&nbsp;&lt;-&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;(&nbsp;f&nbsp;steps&nbsp;(&nbsp;etapes&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;s.(etapes)&nbsp;&lt;-&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sequence&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_poly_to_complex_vector&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limit&nbsp;=&nbsp;accelerator&nbsp;sequence&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;limit&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_compensated_shifted_spectrum accelerator stages factor threshold_qr threshold steps_qr steps shift matrix</pre> 
The <code class="code">accelerator</code> is appied to real vectors. The <code class="code">factor</code> must be chosen 0 and 1.
<p>

L'accélérateur <code class="code">accelerator</code> s'applique aux vecteurs réels. Le facteur <code class="code">factor</code> doit être choisi entre 0 et 1. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_compensated_shifted_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accelerator&nbsp;(stages:int)&nbsp;(factor:float)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;factor&nbsp;**&nbsp;(&nbsp;float&nbsp;p&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;stages&nbsp;1&nbsp;complex_0<br>
&nbsp;<span class="keyword">and</span>&nbsp;etapes&nbsp;=&nbsp;pred&nbsp;stages&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;etapes&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;s.(i)&nbsp;&lt;-&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;(&nbsp;f&nbsp;steps&nbsp;(&nbsp;etapes&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;shift&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;s.(etapes)&nbsp;&lt;-&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;shift&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sequence&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;complex_poly_to_complex_vector&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limit&nbsp;=&nbsp;accelerator&nbsp;sequence&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;complex_vector_to_complex_poly&nbsp;limit&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_complex_compensated_spectrum accelerator_sci_1024 stages factor threshold_qr threshold steps_qr steps matrix</pre> 
The <code class="code">accelerator</code> is appied to complex numbers with extended precision, like <code class="code"><span class="constructor">Sci</span>.approx_1024</code>. 
The <code class="code">factor</code> must be chosen 0 and 1.
<p>

L'accélérateur <code class="code">accelerator</code> s'applique aux nombres complexes en précision étendue, comme <code class="code"><span class="constructor">Sci</span>.approx_1024</code>. 
Le facteur <code class="code">factor</code> doit être choisi entre 0 et 1. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_complex_compensated_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accelerator&nbsp;(stages:int)&nbsp;(factor:float)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;factor&nbsp;**&nbsp;(&nbsp;float&nbsp;p&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;stages&nbsp;1&nbsp;complex_0<br>
&nbsp;<span class="keyword">and</span>&nbsp;etapes&nbsp;=&nbsp;pred&nbsp;stages&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;etapes&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;s.(i)&nbsp;&lt;-&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;(&nbsp;f&nbsp;steps&nbsp;(&nbsp;etapes&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;s.(etapes)&nbsp;&lt;-&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sequence&nbsp;=&nbsp;<span class="constructor">Util</span>.transpose&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;seq&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_complex_to_sci&nbsp;sequence&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limits&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;accelerator&nbsp;seq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_sci_to_complex&nbsp;limits&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_complex_compensated_shifted_spectrum accelerator_sci_1024 stages factor threshold_qr threshold steps_qr steps shift matrix</pre> 
The <code class="code">accelerator</code> is appied to complex numbers with extended precision, like <code class="code"><span class="constructor">Sci</span>.approx_1024</code>. 
The <code class="code">factor</code> must be chosen 0 and 1.
<p>

L'accélérateur <code class="code">accelerator</code> s'applique aux nombres complexes en précision étendue, comme <code class="code"><span class="constructor">Sci</span>.approx_1024</code>. 
Le facteur <code class="code">factor</code> doit être choisi entre 0 et 1. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_complex_compensated_shifted_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;accelerator&nbsp;(stages:int)&nbsp;(factor:float)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;int_of_float&nbsp;(&nbsp;(&nbsp;factor&nbsp;**&nbsp;(&nbsp;float&nbsp;p&nbsp;)&nbsp;)&nbsp;*.&nbsp;(&nbsp;float&nbsp;n&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;stages&nbsp;1&nbsp;complex_0<br>
&nbsp;<span class="keyword">and</span>&nbsp;etapes&nbsp;=&nbsp;pred&nbsp;stages&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;etapes&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;s.(i)&nbsp;&lt;-&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;(&nbsp;f&nbsp;steps&nbsp;(&nbsp;etapes&nbsp;-&nbsp;i&nbsp;)&nbsp;)&nbsp;shift&nbsp;m<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;s.(etapes)&nbsp;&lt;-&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;steps&nbsp;shift&nbsp;m&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;sequence&nbsp;=&nbsp;<span class="constructor">Util</span>.transpose&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;seq&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_complex_to_sci&nbsp;sequence&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;limits&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;accelerator&nbsp;seq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poly_sci_to_complex&nbsp;limits&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>clean_complex_spectrum stages steps matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;clean_complex_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(stages:int)&nbsp;(steps:int)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;largo_complex_compensated_spectrum&nbsp;<span class="constructor">Sci</span>.approx_1024&nbsp;stages&nbsp;0.58&nbsp;0.&nbsp;0.&nbsp;steps&nbsp;steps&nbsp;m&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>clean_complex_shifted_spectrum stages steps shift matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;clean_complex_shifted_spectrum&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(stages:int)&nbsp;(steps:int)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;largo_complex_compensated_shifted_spectrum&nbsp;<span class="constructor">Sci</span>.approx_1024&nbsp;stages&nbsp;0.58&nbsp;0.&nbsp;0.&nbsp;steps&nbsp;steps&nbsp;shift&nbsp;m&nbsp;;;<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_raw_roots spectrum_methode jordan_decomposition_methode polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_raw_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;spectrum_methode&nbsp;jordan_decomposition_methode&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;spectrum_methode&nbsp;(&nbsp;jordan_decomposition_methode&nbsp;p&nbsp;(&nbsp;complex_companion&nbsp;p&nbsp;)&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_complex_raw_roots spectrum_method jordan_decomposition_methode real_polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_complex_raw_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;spectrum_methode&nbsp;jordan_decomposition_methode&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_real_to_complex&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;spectrum_methode&nbsp;(&nbsp;jordan_decomposition_methode&nbsp;q&nbsp;(&nbsp;complex_companion&nbsp;q&nbsp;)&nbsp;).(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_tune_root_step eval_rule polynomial derivative_array threshold candidate</pre> 
The array of successive derivatives <code class="code">derivative_array</code> must contain at least <code class="code">p</code> and <code class="code">p'</code>.
A good value for <code class="code">threshold</code> may lie between <code class="code">min_float</code> and <code class="code">epsilon_float</code>.
Output : estimated root, estimated multiplicity, module of the evaluation of the polynomial at the estimated root, 
successive derivative array.
<p>

Sortie : racine estimée, multiplicité estimée, module de l'évaluation du polynôme en la racine, tableau des dérivées successives.
Le tableau de dérivées successives doit contenir au moins p et p'.
Une bonne valeur pour le seuil <code class="code">threshold</code> peut être entre <code class="code">min_float</code> et <code class="code">epsilon_float</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_tune_root_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(derivative_array:float&nbsp;array&nbsp;array&nbsp;array&nbsp;array)&nbsp;(threshold:float)&nbsp;(z0:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;ref&nbsp;z0<br>
&nbsp;<span class="keyword">and</span>&nbsp;mult&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;old_z&nbsp;=&nbsp;ref&nbsp;z0<br>
&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;max_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;old_error&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;z0&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;deriv&nbsp;=&nbsp;ref&nbsp;derivative_array&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!old_error&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;last_deriv&nbsp;=&nbsp;!deriv.(!i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;!deriv.(!i)&nbsp;z0&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!error&nbsp;&gt;&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;mult&nbsp;:=&nbsp;!i&nbsp;;&nbsp;i&nbsp;:=&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_complex_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|[|&nbsp;!z&nbsp;;&nbsp;[|[|&nbsp;float&nbsp;!mult&nbsp;|]|]&nbsp;;&nbsp;[|[|&nbsp;!old_error&nbsp;|]|]&nbsp;|]|]&nbsp;;&nbsp;!deriv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;last_deriv&nbsp;=&nbsp;!deriv.(!i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;denom&nbsp;=&nbsp;(&nbsp;eval_rule&nbsp;last_deriv&nbsp;z0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;denom&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error&nbsp;:=&nbsp;!error&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_complex_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;quotient&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;(&nbsp;eval_rule&nbsp;(&nbsp;!deriv.(&nbsp;!i&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;z0&nbsp;)&nbsp;(&nbsp;complex_inv&nbsp;denom&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_z&nbsp;:=&nbsp;!z&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;:=&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;z0&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_mult&nbsp;(&nbsp;float&nbsp;!i&nbsp;)&nbsp;quotient&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error&nbsp;:=&nbsp;!error&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!z&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!error&nbsp;&gt;&nbsp;!old_error&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;z&nbsp;:=&nbsp;!old_z&nbsp;;&nbsp;error&nbsp;:=&nbsp;!old_error&nbsp;;&nbsp;i&nbsp;:=&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult&nbsp;:=&nbsp;!mult&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_complex_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|[|&nbsp;!z&nbsp;;&nbsp;[|[|&nbsp;float&nbsp;(&nbsp;!mult&nbsp;)&nbsp;|]|]&nbsp;;&nbsp;[|[|&nbsp;!error&nbsp;|]|]&nbsp;|]|]&nbsp;;&nbsp;!deriv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_complex_tune_roots eval_rule threshold mult_threshold max_steps candidates complex_polynomial</pre>
Output : estimated roots, estimated multiplicities with <code class="code">mult_threshold</code>, means of estimated multiplicities during
the iteration, modules of the evaluations of the polynomial at the estimated roots, successive derivative array.
<p>

Sortie : racines estimées, multiplicités estimées avec <code class="code">mult_threshold</code>, moyenne des multiplicités estimées pendant l'itération,
modules des évaluations du polynôme en les racines, tableau des dérivées successives. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;x&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_complex_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_error&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;max_float<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;candidates<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mult&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;d&nbsp;1&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multiplicity&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;roots&nbsp;=&nbsp;poly_complex_copy&nbsp;candidates<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;steps&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;poly_complex_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;!derivative_array&nbsp;threshold&nbsp;roots.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Array</span>.append&nbsp;mult.(i)&nbsp;[|&nbsp;result.(0).(0).(1).(0).(0)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;&lt;&nbsp;<span class="constructor">Array</span>.length&nbsp;result.(1)&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;result.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;result.(0).(0).(2).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;&gt;&nbsp;old_error.(i)&nbsp;<span class="keyword">then</span>&nbsp;j&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_roots.(i)&nbsp;&lt;-&nbsp;roots.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(i)&nbsp;&lt;-&nbsp;result.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error.(i)&nbsp;&lt;-&nbsp;error.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.(i)&nbsp;&lt;-&nbsp;test&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;multiplicity.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_mean&nbsp;mult.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_complex_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;roots.(i)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;float&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;roots&nbsp;;&nbsp;[|[|&nbsp;multip&nbsp;|]|]&nbsp;;&nbsp;[|[|&nbsp;multiplicity&nbsp;|]|]&nbsp;;&nbsp;[|[|&nbsp;error&nbsp;|]|]&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_tune_root_step eval_rule polynomial derivative_array threshold candidate</pre> 
The array of successive derivatives <code class="code">derivative_array</code> must contain at least <code class="code">p</code> and <code class="code">p'</code>.
A good value for <code class="code">threshold</code> may lie between <code class="code">min_float</code> and <code class="code">epsilon_float</code>.
Output : estimated root, estimated multiplicity, module of the evaluation of the polynomial at the estimated root, 
successive derivative array.
<p>

Sortie : racine estimée, multiplicité estimée, module de l'évaluation du polynôme en la racine, tableau des dérivées successives.
Le tableau de dérivées successives doit contenir au moins p et p'.
Une bonne valeur pour le seuil <code class="code">threshold</code> peut être entre <code class="code">min_float</code> et <code class="code">epsilon_float</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_tune_root_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(derivative_array:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array&nbsp;array)&nbsp;(threshold:float)&nbsp;(z0:<span class="constructor">Num</span>.num&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;ref&nbsp;z0<br>
&nbsp;<span class="keyword">and</span>&nbsp;mult&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;old_z&nbsp;=&nbsp;ref&nbsp;z0<br>
&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;max_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;old_error&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;z0&nbsp;)&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;deriv&nbsp;=&nbsp;ref&nbsp;derivative_array&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!old_error&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;last_deriv&nbsp;=&nbsp;!deriv.(!i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!deriv.(!i)&nbsp;z0&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!error&nbsp;&gt;&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;mult&nbsp;:=&nbsp;!i&nbsp;;&nbsp;i&nbsp;:=&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_sci_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|[|&nbsp;!z&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;!mult&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;!old_error&nbsp;|]|]&nbsp;;&nbsp;!deriv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;last_deriv&nbsp;=&nbsp;!deriv.(!i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;denom&nbsp;=&nbsp;(&nbsp;eval_rule&nbsp;last_deriv&nbsp;z0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;denom&nbsp;)&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error&nbsp;:=&nbsp;!error&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_sci_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;quotient&nbsp;=&nbsp;<span class="constructor">Sci</span>.mult&nbsp;(&nbsp;eval_rule&nbsp;(&nbsp;!deriv.(&nbsp;!i&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;z0&nbsp;)&nbsp;(&nbsp;<span class="constructor">Sci</span>.inv&nbsp;denom&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_z&nbsp;:=&nbsp;!z&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;:=&nbsp;<span class="constructor">Sci</span>.minus&nbsp;z0&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult&nbsp;(&nbsp;<span class="constructor">Sci</span>.format&nbsp;[|&nbsp;<span class="constructor">Num</span>.num_of_int&nbsp;!i&nbsp;;&nbsp;<span class="constructor">Sci</span>.num_0&nbsp;;&nbsp;<span class="constructor">Sci</span>.num_0&nbsp;|]&nbsp;)&nbsp;quotient&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error&nbsp;:=&nbsp;!error&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!z&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!error&nbsp;&gt;&nbsp;!old_error&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;z&nbsp;:=&nbsp;!old_z&nbsp;;&nbsp;error&nbsp;:=&nbsp;!old_error&nbsp;;&nbsp;i&nbsp;:=&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult&nbsp;:=&nbsp;!mult&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_sci_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|[|&nbsp;!z&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;(&nbsp;!mult&nbsp;)&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;!error&nbsp;|]|]&nbsp;;&nbsp;!deriv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_tune_roots eval_rule threshold mult_threshold max_steps candidates sci_polynomial</pre>
Output : estimated roots, estimated multiplicities with <code class="code">mult_threshold</code>, means of estimated multiplicities during
the iteration, modules of the evaluations of the polynomial at the estimated roots, successive derivative array.
<p>

Sortie : racines estimées, multiplicités estimées avec <code class="code">mult_threshold</code>, moyenne des multiplicités estimées pendant l'itération,
carrés des modules des évaluations du polynôme en les racines, tableau des dérivées successives. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;x&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_error&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;max_float<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;candidates<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mult&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;d&nbsp;1&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multiplicity&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;roots&nbsp;=&nbsp;poly_sci_copy&nbsp;candidates<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;steps&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;poly_sci_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;!derivative_array&nbsp;threshold&nbsp;roots.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Array</span>.append&nbsp;mult.(i)&nbsp;[|&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;result.(0).(0).(1)&nbsp;).(0).(0)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;&lt;&nbsp;<span class="constructor">Array</span>.length&nbsp;result.(1)&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;result.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;result.(0).(0).(2)&nbsp;).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;&gt;&nbsp;old_error.(i)&nbsp;<span class="keyword">then</span>&nbsp;j&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_roots.(i)&nbsp;&lt;-&nbsp;roots.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(i)&nbsp;&lt;-&nbsp;result.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error.(i)&nbsp;&lt;-&nbsp;error.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.(i)&nbsp;&lt;-&nbsp;test&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;multiplicity.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_mean&nbsp;mult.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;(&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;roots.(i)&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;roots&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;multiplicity&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;error&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_tune_root_step eval_rule polynomial derivative_array threshold candidate</pre> 
The array of successive derivatives <code class="code">derivative_array</code> must contain at least <code class="code">p</code> and <code class="code">p'</code>.
A good value for <code class="code">threshold</code> may lie between <code class="code">min_float</code> and <code class="code">epsilon_float</code>.
Output : estimated root, estimated multiplicity, module of the evaluation of the polynomial at the estimated root, 
successive derivative array.
<p>

Sortie : racine estimée, multiplicité estimée, module de l'évaluation du polynôme en la racine, tableau des dérivées successives.
Le tableau de dérivées successives doit contenir au moins p et p'.
Une bonne valeur pour le seuil <code class="code">threshold</code> peut être entre <code class="code">min_float</code> et <code class="code">epsilon_float</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_tune_root_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(derivative_array:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array&nbsp;array)&nbsp;(threshold:float)&nbsp;(z0:<span class="constructor">Num</span>.num&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;ref&nbsp;z0<br>
&nbsp;<span class="keyword">and</span>&nbsp;mult&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;old_z&nbsp;=&nbsp;ref&nbsp;z0<br>
&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;max_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;old_error&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;z0&nbsp;)&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;i&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;deriv&nbsp;=&nbsp;ref&nbsp;derivative_array&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!old_error&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;last_deriv&nbsp;=&nbsp;!deriv.(!i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!deriv.(!i)&nbsp;z0&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!error&nbsp;&gt;&nbsp;threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;mult&nbsp;:=&nbsp;!i&nbsp;;&nbsp;i&nbsp;:=&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|[|&nbsp;!z&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;!mult&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;!old_error&nbsp;|]|]&nbsp;;&nbsp;!deriv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!i&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;last_deriv&nbsp;=&nbsp;!deriv.(!i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;denom&nbsp;=&nbsp;(&nbsp;eval_rule&nbsp;last_deriv&nbsp;z0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;denom&nbsp;)&nbsp;&lt;=&nbsp;threshold&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error&nbsp;:=&nbsp;!error&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;quotient&nbsp;=&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;(&nbsp;eval_rule&nbsp;(&nbsp;!deriv.(&nbsp;!i&nbsp;-&nbsp;1&nbsp;)&nbsp;)&nbsp;z0&nbsp;)&nbsp;(&nbsp;<span class="constructor">Sci</span>.inv_1024&nbsp;denom&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_z&nbsp;:=&nbsp;!z&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;:=&nbsp;<span class="constructor">Sci</span>.minus_1024&nbsp;z0&nbsp;(&nbsp;<span class="constructor">Sci</span>.mult_1024&nbsp;(&nbsp;<span class="constructor">Sci</span>.format_1024&nbsp;[|&nbsp;<span class="constructor">Num</span>.num_of_int&nbsp;!i&nbsp;;&nbsp;<span class="constructor">Sci</span>.num_0&nbsp;;&nbsp;<span class="constructor">Sci</span>.num_0&nbsp;|]&nbsp;)&nbsp;quotient&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error&nbsp;:=&nbsp;!error&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!z&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;!error&nbsp;&gt;&nbsp;!old_error&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;z&nbsp;:=&nbsp;!old_z&nbsp;;&nbsp;error&nbsp;:=&nbsp;!old_error&nbsp;;&nbsp;i&nbsp;:=&nbsp;d&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult&nbsp;:=&nbsp;!mult&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;!i&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;!deriv&nbsp;)&nbsp;&lt;=&nbsp;!i&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;deriv&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!deriv&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;last_deriv&nbsp;|]&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;[|[|&nbsp;!z&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;(&nbsp;!mult&nbsp;)&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;!error&nbsp;|]|]&nbsp;;&nbsp;!deriv&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_sci_1024_tune_roots eval_rule threshold mult_threshold max_steps candidates sci_polynomial</pre>
Output : estimated roots, estimated multiplicities with <code class="code">mult_threshold</code>, means of estimated multiplicities during
the iteration, modules of the evaluations of the polynomial at the estimated roots, successive derivative array.
<p>

Sortie : racines estimées, multiplicités estimées avec <code class="code">mult_threshold</code>, moyenne des multiplicités estimées pendant l'itération,
carrés des modules des évaluations du polynôme en les racines, tableau des dérivées successives. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_sci_1024_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;x&nbsp;)&nbsp;)<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_1024_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_error&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;max_float<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;error&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;candidates<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;mult&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;d&nbsp;1&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multiplicity&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1.<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;roots&nbsp;=&nbsp;poly_sci_copy&nbsp;candidates<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;old_roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;dd&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;steps&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;!derivative_array&nbsp;threshold&nbsp;roots.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Array</span>.append&nbsp;mult.(i)&nbsp;[|&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;result.(0).(0).(1)&nbsp;).(0).(0)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;&lt;&nbsp;<span class="constructor">Array</span>.length&nbsp;result.(1)&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;result.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;result.(0).(0).(2)&nbsp;).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;&gt;&nbsp;old_error.(i)&nbsp;<span class="keyword">then</span>&nbsp;j&nbsp;:=&nbsp;max_int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_roots.(i)&nbsp;&lt;-&nbsp;roots.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(i)&nbsp;&lt;-&nbsp;result.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_error.(i)&nbsp;&lt;-&nbsp;error.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error.(i)&nbsp;&lt;-&nbsp;test&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;multiplicity.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_mean&nbsp;mult.(i)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;roots.(i)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;roots&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;multiplicity&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;error&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_real_complex_tune_roots eval_rule threshold mult_threshold max_steps candidates real_polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_real_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;poly_complex_tune_roots&nbsp;eval_rule&nbsp;threshold&nbsp;mult_threshold&nbsp;steps&nbsp;candidates&nbsp;(&nbsp;poly_real_to_complex&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>lento_poly_complex_tune_roots eval_rule threshold mult_threshold steps candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;lento_poly_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;(&nbsp;poly_sci_tune_roots&nbsp;eval_rule&nbsp;threshold&nbsp;mult_threshold&nbsp;steps&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;candidates&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>lento_poly_real_complex_tune_roots eval_rule threshold mult_threshold steps candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;lento_poly_real_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;(&nbsp;&nbsp;poly_sci_tune_roots&nbsp;eval_rule&nbsp;threshold&nbsp;mult_threshold&nbsp;steps&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;candidates&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_poly_complex_tune_roots eval_rule threshold mult_threshold steps candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_poly_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;(&nbsp;poly_sci_1024_tune_roots&nbsp;eval_rule&nbsp;threshold&nbsp;mult_threshold&nbsp;steps&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;candidates&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_poly_real_complex_tune_roots eval_rule threshold mult_threshold steps candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_poly_real_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(steps:int)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;f&nbsp;(&nbsp;&nbsp;poly_sci_1024_tune_roots&nbsp;eval_rule&nbsp;threshold&nbsp;mult_threshold&nbsp;steps&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;candidates&nbsp;)&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;p&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_aitken_seki_1024_tune_roots eval_rule threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_aitken_seki_1024_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ra&nbsp;=&nbsp;candidates.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rb&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;!derivative_array&nbsp;threshold&nbsp;ra&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rc&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;rb.(1)&nbsp;threshold&nbsp;rb.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rd&nbsp;=&nbsp;<span class="constructor">Sci</span>.aitken_seki_1024&nbsp;ra&nbsp;rb.(0).(0).(0)&nbsp;rc.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;rd&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;rc.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;rd&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_shanks2_1024_tune_roots eval_rule threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_shanks2_1024_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ra&nbsp;=&nbsp;candidates.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rb&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;!derivative_array&nbsp;threshold&nbsp;ra&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rc&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;rb.(1)&nbsp;threshold&nbsp;rb.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rd&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;rc.(1)&nbsp;threshold&nbsp;rc.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;re&nbsp;=&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;rd.(1)&nbsp;threshold&nbsp;rd.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rf&nbsp;=&nbsp;<span class="constructor">Sci</span>.shanks2_1024&nbsp;ra&nbsp;rb.(0).(0).(0)&nbsp;rc.(0).(0).(0)&nbsp;rd.(0).(0).(0)&nbsp;re.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;rf&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;re.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;rf&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_wynn_1024_tune_roots eval_rule half_order threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_wynn_1024_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(k:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;dk&nbsp;=&nbsp;2&nbsp;*&nbsp;k<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;kk&nbsp;=&nbsp;succ&nbsp;dk<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;kk&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;1&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(0)&nbsp;&lt;-&nbsp;[|&nbsp;[|[|&nbsp;candidates.(i)&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;max_float&nbsp;|]|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;dk&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;racine&nbsp;=&nbsp;roots.(&nbsp;pred&nbsp;index&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(index)&nbsp;&lt;-&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;racine.(1)&nbsp;threshold&nbsp;racine.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;estimate&nbsp;=&nbsp;<span class="constructor">Sci</span>.wynn_1024&nbsp;dk&nbsp;0&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0).(0)&nbsp;)&nbsp;roots&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;estimate&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;roots.(dk).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;estimate&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_brezinski_1024_tune_roots eval_rule half_order threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_brezinski_1024_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(k:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;dk&nbsp;=&nbsp;2&nbsp;*&nbsp;k<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;kk&nbsp;=&nbsp;succ&nbsp;dk<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;kk&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;1&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(0)&nbsp;&lt;-&nbsp;[|&nbsp;[|[|&nbsp;candidates.(i)&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;max_float&nbsp;|]|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;dk&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;racine&nbsp;=&nbsp;roots.(&nbsp;pred&nbsp;index&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(index)&nbsp;&lt;-&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;racine.(1)&nbsp;threshold&nbsp;racine.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;estimate&nbsp;=&nbsp;<span class="constructor">Sci</span>.brezinski_1024&nbsp;(&nbsp;dk&nbsp;-&nbsp;2&nbsp;)&nbsp;0&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0).(0)&nbsp;)&nbsp;roots&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;estimate&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;roots.(dk).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;estimate&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_aitken_seki_rec_1024_tune_roots eval_rule half_order threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(k:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;dk&nbsp;=&nbsp;2&nbsp;*&nbsp;k<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_sci_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_sci_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;<span class="constructor">Sci</span>.sci_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;kk&nbsp;=&nbsp;succ&nbsp;dk<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;kk&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;1&nbsp;1&nbsp;<span class="constructor">Sci</span>.sci_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(0)&nbsp;&lt;-&nbsp;[|&nbsp;[|[|&nbsp;candidates.(i)&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_1&nbsp;;&nbsp;<span class="constructor">Sci</span>.sci_of_float&nbsp;max_float&nbsp;|]|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;dk&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;racine&nbsp;=&nbsp;roots.(&nbsp;pred&nbsp;index&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(index)&nbsp;&lt;-&nbsp;poly_sci_1024_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;racine.(1)&nbsp;threshold&nbsp;racine.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;estimate&nbsp;=&nbsp;<span class="constructor">Sci</span>.aitken_seki_rec_1024&nbsp;k&nbsp;0&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0).(0)&nbsp;)&nbsp;roots&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;estimate&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;roots.(dk).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_sci_1024_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;estimate&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.sci_of_int&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_aitken_seki_complex_tune_roots eval_rule threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_aitken_seki_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_complex_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;complex_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ra&nbsp;=&nbsp;candidates.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rb&nbsp;=&nbsp;poly_complex_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;!derivative_array&nbsp;threshold&nbsp;ra&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rc&nbsp;=&nbsp;poly_complex_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;rb.(1)&nbsp;threshold&nbsp;rb.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rd&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_aitken_seki&nbsp;ra&nbsp;rb.(0).(0).(0)&nbsp;rc.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;rd&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;rc.(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_complex_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;rd&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;int_to_complex&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_wynn_complex_tune_roots eval_rule half_order threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_wynn_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(k:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;dk&nbsp;=&nbsp;2&nbsp;*&nbsp;k<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_complex_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;complex_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;kk&nbsp;=&nbsp;succ&nbsp;dk<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;kk&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;1&nbsp;1&nbsp;complex_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(0)&nbsp;&lt;-&nbsp;[|&nbsp;[|[|&nbsp;candidates.(i)&nbsp;;&nbsp;complex_1&nbsp;;&nbsp;float_to_complex&nbsp;max_float&nbsp;|]|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;dk&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;racine&nbsp;=&nbsp;roots.(&nbsp;pred&nbsp;index&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(index)&nbsp;&lt;-&nbsp;poly_complex_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;racine.(1)&nbsp;threshold&nbsp;racine.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;estimate&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_wynn&nbsp;dk&nbsp;0&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0).(0)&nbsp;)&nbsp;roots&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;estimate&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;roots.(dk).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_complex_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;estimate&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;int_to_complex&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_brezinski_complex_tune_roots eval_rule half_order threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_brezinski_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(k:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;dk&nbsp;=&nbsp;2&nbsp;*&nbsp;k<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_complex_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;complex_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;kk&nbsp;=&nbsp;succ&nbsp;dk<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;d&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;kk&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;1&nbsp;1&nbsp;complex_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(0)&nbsp;&lt;-&nbsp;[|&nbsp;[|[|&nbsp;candidates.(i)&nbsp;;&nbsp;complex_1&nbsp;;&nbsp;float_to_complex&nbsp;max_float&nbsp;|]|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;dk&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;racine&nbsp;=&nbsp;roots.(&nbsp;pred&nbsp;index&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(index)&nbsp;&lt;-&nbsp;poly_complex_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;racine.(1)&nbsp;threshold&nbsp;racine.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;estimate&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_brezinski&nbsp;(&nbsp;dk&nbsp;-&nbsp;2&nbsp;)&nbsp;0&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0).(0)&nbsp;)&nbsp;roots&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;estimate&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;roots.(dk).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_complex_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;estimate&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;int_to_complex&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>poly_aitken_seki_rec_complex_tune_roots eval_rule half_order threshold mult_threshold candidates polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(k:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(candidates:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;candidates<br>
&nbsp;<span class="keyword">and</span>&nbsp;dk&nbsp;=&nbsp;2&nbsp;*&nbsp;k<br>
&nbsp;<span class="keyword">and</span>&nbsp;derivative_array&nbsp;=&nbsp;ref&nbsp;[|&nbsp;p&nbsp;;&nbsp;poly_complex_deriv&nbsp;p&nbsp;|]<br>
&nbsp;<span class="keyword">and</span>&nbsp;j&nbsp;=&nbsp;ref&nbsp;1<br>
&nbsp;<span class="keyword">and</span>&nbsp;d&nbsp;=&nbsp;int_of_float&nbsp;(&nbsp;poly_complex_deg&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;complex_0<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;kk&nbsp;=&nbsp;succ&nbsp;dk<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;d<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;multip&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;l&nbsp;1&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;kk&nbsp;1&nbsp;(&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;1&nbsp;1&nbsp;complex_0&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;l&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(0)&nbsp;&lt;-&nbsp;[|&nbsp;[|[|&nbsp;candidates.(i)&nbsp;;&nbsp;complex_1&nbsp;;&nbsp;float_to_complex&nbsp;max_float&nbsp;|]|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;dk&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;racine&nbsp;=&nbsp;roots.(&nbsp;pred&nbsp;index&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roots.(index)&nbsp;&lt;-&nbsp;poly_complex_tune_root_step&nbsp;eval_rule&nbsp;p&nbsp;racine.(1)&nbsp;threshold&nbsp;racine.(0).(0).(0)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;estimate&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_aitken_seki_rec&nbsp;k&nbsp;0&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x.(0).(0).(0)&nbsp;)&nbsp;roots&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z.(i)&nbsp;&lt;-&nbsp;estimate&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derivative_array&nbsp;:=&nbsp;roots.(dk).(1)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!j&nbsp;&lt;&nbsp;d&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;!derivative_array&nbsp;=&nbsp;!j&nbsp;<span class="keyword">then</span>&nbsp;derivative_array&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!derivative_array&nbsp;[|&nbsp;poly_complex_deriv&nbsp;!derivative_array.(&nbsp;!j&nbsp;-&nbsp;1&nbsp;)&nbsp;|]&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;essai&nbsp;=&nbsp;complex_module&nbsp;(&nbsp;eval_rule&nbsp;!derivative_array.(!j)&nbsp;estimate&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;essai&nbsp;&gt;&nbsp;mult_threshold&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;accu&nbsp;:=&nbsp;!j&nbsp;;&nbsp;j&nbsp;:=&nbsp;d&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;!j&nbsp;+&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multip.(i)&nbsp;&lt;-&nbsp;!accu&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;1&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;[|&nbsp;[|&nbsp;z&nbsp;;&nbsp;<span class="constructor">Array</span>.map&nbsp;int_to_complex&nbsp;multip&nbsp;|]&nbsp;;&nbsp;!derivative_array&nbsp;|]&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_complex_roots eval_rule stages_spectrum stages_roots steps threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_complex_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_complex_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_div&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_solve_degree_2&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;clean_complex_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_complex_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>maehly_complex_step eval_rule roots polynomial derivative value</pre> The algorithm is described at the following address.
<p>

www.cs.iastate.edu/~cs577/handouts/polyroots.pdf
<p>

L'algorithme est décrit à l'adresse précédente. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;maehly_complex_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(r:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(der_p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(x:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;vector&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;x&nbsp;)&nbsp;r<br>
&nbsp;<span class="keyword">and</span>&nbsp;numerator&nbsp;=&nbsp;eval_rule&nbsp;p&nbsp;x<br>
&nbsp;<span class="keyword">and</span>&nbsp;init&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;(&nbsp;eval_rule&nbsp;der_p&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;other_vector&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;complex_div&nbsp;numerator&nbsp;)&nbsp;vector&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;denominator&nbsp;=&nbsp;<span class="constructor">Array</span>.fold_left&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;init&nbsp;other_vector&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;fraction&nbsp;=&nbsp;complex_div&nbsp;numerator&nbsp;denominator&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;x&nbsp;fraction&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_maehly_complex_roots mult_rule eval_rule stages_spectrum stages_roots steps threshold roots polynomial derivative</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_maehly_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(r:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(der_p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;float&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;r&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_maehly_complex_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;-.&nbsp;n&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;dd&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Too&nbsp;much&nbsp;roots&nbsp;in&nbsp;Reduc.simple_maehly_complex_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;dd&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;r<br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_div&nbsp;q.(0)&nbsp;q.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;(&nbsp;complex_solve_degree_2&nbsp;q.(2)&nbsp;q.(1)&nbsp;q.(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;r&nbsp;&gt;&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">else</span>&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;matrix_unitary_random&nbsp;(&nbsp;pred&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;)&nbsp;1.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean_complex_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean_complex_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;m<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;s.(0)&nbsp;|]&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;ref&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_abs_sum&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!a&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!error&nbsp;&gt;&nbsp;threshold&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;:=&nbsp;maehly_complex_step&nbsp;eval_rule&nbsp;r&nbsp;p&nbsp;der_p&nbsp;!a&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_abs_sum&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!a&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simple_maehly_complex_roots&nbsp;mult_rule&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;[|&nbsp;!a&nbsp;|]&nbsp;)&nbsp;p&nbsp;der_p<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_sci_1024_roots eval_rule stages_spectrum stages_roots steps threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_sci_1024_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_sci_1024_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_sci_1024_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Sci</span>.opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_2_1024&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;3.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_3_1024&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;4.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_4_1024&nbsp;p.(4)&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_to_complex&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;clean_complex_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_sci_1024_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>maehly_sci_1024_step eval_rule roots polynomial derivative value</pre> The algorithm is described at the following address.
<p>

www.cs.iastate.edu/~cs577/handouts/polyroots.pdf
<p>

L'algorithme est décrit à l'adresse précédente. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;maehly_sci_1024_step&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(r:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(der_p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(x:<span class="constructor">Num</span>.num&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;vector&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.minus_1024&nbsp;x&nbsp;)&nbsp;r<br>
&nbsp;<span class="keyword">and</span>&nbsp;numerator&nbsp;=&nbsp;eval_rule&nbsp;p&nbsp;x<br>
&nbsp;<span class="keyword">and</span>&nbsp;init&nbsp;=&nbsp;<span class="constructor">Sci</span>.opp&nbsp;(&nbsp;eval_rule&nbsp;der_p&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;other_vector&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;numerator&nbsp;)&nbsp;vector&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;denominator&nbsp;=&nbsp;<span class="constructor">Array</span>.fold_left&nbsp;<span class="constructor">Sci</span>.plus_1024&nbsp;init&nbsp;other_vector&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;fraction&nbsp;=&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;numerator&nbsp;denominator&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Sci</span>.plus_1024&nbsp;x&nbsp;fraction&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_maehly_sci_1024_roots mult_rule eval_rule stages_spectrum stages_roots steps threshold roots polynomial derivative</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_maehly_sci_1024_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(r:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;(der_p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p<br>
&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;float&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;r&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_maehly_sci_1024_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;d&nbsp;-.&nbsp;n&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;dd&nbsp;&lt;&nbsp;0.&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Too&nbsp;much&nbsp;roots&nbsp;in&nbsp;Reduc.simple_maehly_sci_1024_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;dd&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;r<br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_1024_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;q.(0)&nbsp;q.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;[|&nbsp;<span class="constructor">Sci</span>.opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_1024_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;(&nbsp;<span class="constructor">Sci</span>.solve_degree_2_1024&nbsp;q.(2)&nbsp;q.(1)&nbsp;q.(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;3.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_1024_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;(&nbsp;<span class="constructor">Sci</span>.solve_degree_3_1024&nbsp;q.(3)&nbsp;q.(2)&nbsp;q.(1)&nbsp;q.(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;4.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_1024_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;(&nbsp;<span class="constructor">Sci</span>.solve_degree_4_1024&nbsp;q.(4)&nbsp;q.(3)&nbsp;q.(2)&nbsp;q.(1)&nbsp;q.(0)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Array</span>.length&nbsp;r&nbsp;&gt;&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_1024_from_roots&nbsp;mult_rule&nbsp;r&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">else</span>&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;qq&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;qq&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;u&nbsp;=&nbsp;matrix_unitary_random&nbsp;(&nbsp;pred&nbsp;(&nbsp;<span class="constructor">Array</span>.length&nbsp;p&nbsp;)&nbsp;)&nbsp;1.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_twisted_prod&nbsp;u&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean_complex_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean_complex_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;m<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;s.(0)&nbsp;|]&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;ref&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;error&nbsp;=&nbsp;ref&nbsp;(&nbsp;complex_abs_sum&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!a&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;!error&nbsp;&gt;&nbsp;threshold&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;:=&nbsp;maehly_sci_1024_step&nbsp;eval_rule&nbsp;r&nbsp;p&nbsp;der_p&nbsp;!a&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;:=&nbsp;complex_abs_sum&nbsp;(&nbsp;<span class="constructor">Sci</span>.complex_of_sci&nbsp;(&nbsp;eval_rule&nbsp;p&nbsp;!a&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simple_maehly_sci_1024_roots&nbsp;mult_rule&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;(&nbsp;<span class="constructor">Array</span>.append&nbsp;r&nbsp;[|&nbsp;!a&nbsp;|]&nbsp;)&nbsp;p&nbsp;der_p<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_simple_complex_roots eval_rule stages_spectrum stages_roots steps threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_simple_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;simple_sci_1024_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_simple_maehly_complex_roots mult_rule eval_rule stages_spectrum stages_roots steps threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_simple_maehly_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_complex_to_sci&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;simple_maehly_sci_1024_roots&nbsp;mult_rule&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;[|&nbsp;|]&nbsp;pp&nbsp;(&nbsp;poly_sci_1024_deriv&nbsp;pp&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_direct_complex_roots eval_rule stages_roots steps threshold_qr threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_direct_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_complex_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_complex_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_div&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_solve_degree_2&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps&nbsp;steps&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_direct_complex_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_direct_sci_1024_roots eval_rule stages_roots steps threshold_qr threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_direct_sci_1024_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_sci_1024_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_sci_1024_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Sci</span>.opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_2_1024&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;3.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_3_1024&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;4.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_4_1024&nbsp;p.(4)&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_to_complex&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;direct_complex_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps&nbsp;steps&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_direct_sci_1024_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_simple_direct_complex_roots eval_rule stages_roots steps threshold_qr threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_simple_direct_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;simple_direct_sci_1024_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>naive_complex_roots eval_rule stages_spectrum stages_roots steps threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;naive_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_complex_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_complex_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_maehly_roots mult_rule eval_rule stages_spectrum stages_roots steps threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_maehly_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_complex_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_maehly_complex_roots&nbsp;mult_rule&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;[|&nbsp;|]&nbsp;q&nbsp;(&nbsp;poly_complex_deriv&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_roots eval_rule stages_roots steps threshold_qr threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_direct_complex_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>naive_sci_1024_roots eval_rule stages_spectrum stages_roots steps threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;naive_sci_1024_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_sci_1024_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_sci_1024_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sci_1024_maehly_roots mult_rule eval_rule stages_spectrum stages_roots steps threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sci_1024_maehly_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;mult_rule&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_sci_1024_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_maehly_sci_1024_roots&nbsp;mult_rule&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;[|&nbsp;|]&nbsp;q&nbsp;(&nbsp;poly_sci_1024_deriv&nbsp;q&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_sci_1024_roots eval_rule stages_roots steps threshold_qr threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_sci_1024_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_direct_sci_1024_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_naive_complex_roots eval_rule stages_spectrum stages_roots steps threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_naive_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;naive_sci_1024_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;mult_threshold&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_direct_complex_roots eval_rule stages_roots steps threshold_qr threshold mult_threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_direct_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;direct_sci_1024_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;mult_threshold&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_complex_shifted_roots eval_rule stages_spectrum stages_roots steps threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_complex_shifted_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_complex_shifted_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_div&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_solve_degree_2&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;clean_complex_shifted_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;shift&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_complex_shifted_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;shift&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_sci_1024_shifted_roots eval_rule stages_spectrum stages_roots steps threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_sci_1024_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_sci_1024_shifted_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_sci_1024_shifted_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Sci</span>.opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_2_1024&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;3.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_3_1024&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;4.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_4_1024&nbsp;p.(4)&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_to_complex&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;clean_complex_shifted_spectrum&nbsp;stages_spectrum&nbsp;steps&nbsp;shift&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;shift&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_simple_complex_shifted_roots eval_rule stages_spectrum stages_roots steps threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;largo_simple_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;simple_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;shift&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_direct_complex_shifted_roots eval_rule stages_roots steps threshold_qr threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_direct_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_complex_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_complex_shifted_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_complex_shifted_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;complex_div&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;complex_solve_degree_2&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps&nbsp;steps&nbsp;shift&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_complex_div&nbsp;p&nbsp;(&nbsp;poly_complex_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_direct_complex_shifted_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;shift&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>simple_direct_sci_1024_shifted_roots eval_rule stages_roots steps threshold_qr threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;simple_direct_sci_1024_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;poly_sci_deg&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;d&nbsp;=&nbsp;neg_infinity&nbsp;<span class="keyword">then</span>&nbsp;failwith&nbsp;<span class="string">"Null&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_sci_1024_shifted_roots."</span>&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;d&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Nonzero&nbsp;constant&nbsp;polynomial&nbsp;in&nbsp;Reduc.simple_direct_sci_1024_shifted_roots."</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;1.&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">Sci</span>.div_1024&nbsp;p.(0)&nbsp;p.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Sci</span>.opp&nbsp;s&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;2.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_2_1024&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;3.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_3_1024&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;4.&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Sci</span>.solve_degree_4_1024&nbsp;p.(4)&nbsp;p.(3)&nbsp;p.(2)&nbsp;p.(1)&nbsp;p.(0)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;poly_sci_to_complex&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;m&nbsp;=&nbsp;complex_companion&nbsp;pp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;direct_complex_shifted_spectrum&nbsp;threshold_qr&nbsp;threshold&nbsp;steps&nbsp;steps&nbsp;shift&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;1.&nbsp;[|&nbsp;<span class="constructor">Sci</span>.sci_of_complex&nbsp;s.(0)&nbsp;|]&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;res.(0).(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;(&nbsp;poly_sci_1024_div&nbsp;p&nbsp;(&nbsp;poly_sci_x_a&nbsp;a&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Array</span>.append&nbsp;[|&nbsp;a&nbsp;|]&nbsp;(&nbsp;simple_direct_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;shift&nbsp;q&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_simple_direct_complex_shifted_roots eval_rule stages_roots steps threshold_qr threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_simple_direct_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;simple_direct_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;shift&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_shifted_roots eval_rule stages_spectrum stages_roots steps threshold mult_threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_complex_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_complex_shifted_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;shift&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sci_1024_shifted_roots eval_rule stages_spectrum stages_roots steps threshold mult_threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sci_1024_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;poly_sci_1024_simplify&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;shift&nbsp;q&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_complex_shifted_roots eval_rule stages_roots steps threshold_qr threshold mult_threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_direct_complex_shifted_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;shift&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_complex_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>direct_sci_1024_shifted_roots eval_rule stages_roots steps threshold_qr threshold mult_threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;direct_sci_1024_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;simple_direct_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;shift&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;poly_aitken_seki_rec_1024_tune_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;threshold&nbsp;mult_threshold&nbsp;s&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;res.(0)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_complex_shifted_roots eval_rule stages_spectrum stages_roots steps threshold mult_threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_spectrum:int)&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_spectrum&nbsp;stages_roots&nbsp;steps&nbsp;threshold&nbsp;mult_threshold&nbsp;shift&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_direct_complex_shifted_roots eval_rule stages_roots steps threshold_qr threshold mult_threshold shift polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_direct_complex_shifted_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;eval_rule&nbsp;(stages_roots:int)&nbsp;(steps:int)&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(mult_threshold:float)&nbsp;(shift:float&nbsp;array&nbsp;array)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;direct_sci_1024_shifted_roots&nbsp;eval_rule&nbsp;stages_roots&nbsp;steps&nbsp;threshold_qr&nbsp;threshold&nbsp;mult_threshold&nbsp;shift&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Array</span>.map&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_roots threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mr&nbsp;=&nbsp;poly_complex_mult<br>
&nbsp;<span class="keyword">and</span>&nbsp;er&nbsp;=&nbsp;poly_complex_evaluate&nbsp;poly_complex_horner_comp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;complex_maehly_roots&nbsp;mr&nbsp;er&nbsp;2&nbsp;0&nbsp;100&nbsp;threshold&nbsp;1.&nbsp;p&nbsp;).(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sci_1024_roots threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sci_1024_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:float)&nbsp;(p:<span class="constructor">Num</span>.num&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mr&nbsp;=&nbsp;poly_sci_1024_mult<br>
&nbsp;<span class="keyword">and</span>&nbsp;er&nbsp;=&nbsp;poly_sci_1024_evaluate&nbsp;poly_sci_1024_horner_comp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;sci_1024_maehly_roots&nbsp;mr&nbsp;er&nbsp;2&nbsp;0&nbsp;100&nbsp;threshold&nbsp;1.&nbsp;p&nbsp;).(0)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>largo_complex_roots threshold polynomial</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;largo_complex_roots&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(threshold:float)&nbsp;(p:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mr&nbsp;=&nbsp;poly_sci_1024_mult<br>
&nbsp;<span class="keyword">and</span>&nbsp;er&nbsp;=&nbsp;poly_sci_1024_evaluate&nbsp;poly_sci_1024_horner_comp&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;(&nbsp;sci_1024_maehly_roots&nbsp;mr&nbsp;er&nbsp;2&nbsp;0&nbsp;100&nbsp;threshold&nbsp;1.&nbsp;(&nbsp;poly_complex_to_sci&nbsp;p&nbsp;)&nbsp;).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;poly_sci_to_complex&nbsp;r&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_diagonalization methode_ker threshold_qr threshold steps_qr steps_power methode_tune_roots char_pol matrix</pre> 
The matrix is supposed to be diagonalizable.
The first number of steps <code class="code">steps_qr</code> is the one used in
the QR algorithm of Francis ; the second <code class="code">steps</code> is the one used in the inverse iteration.
The method <code class="code">methode_ker</code> may be the one used to search for a kernel with the singular value decomposition.
In the case when the matrix is not simple, the passage matrix has few precision.
The output is the same as for <code class="code">direct_complex_diagonalization</code>.
<p>

La sortie est la même que pour <code class="code">direct_complex_diagonalization</code>.
La matrice est supposée diagonalisable.
Le premier nombre maximal de pas <code class="code">steps_qr</code> est celui utilisé pour l'algorithme QR de Francis ;
le deuxième <code class="code">steps</code> est celui utilisé dans l'itération inverse.
La méthode <code class="code">methode_ker</code> peut être celle utilisée pour rechercher un noyau avec la décomposition en valeurs singulières.
Dans le cas où la matrice n'est pas simple, la matrice de passage est peu précise. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_diagonalization&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;methode_ker&nbsp;(threshold_qr:float)&nbsp;(threshold:float)&nbsp;(steps_qr:int)&nbsp;(steps:int)&nbsp;methode_tune_roots&nbsp;(char_pol:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;complex_francis_schur_decomposition&nbsp;threshold_qr&nbsp;threshold&nbsp;steps_qr&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;seuil&nbsp;=&nbsp;sqrt&nbsp;epsilon_float<br>
&nbsp;<span class="keyword">and</span>&nbsp;nn&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;m<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_integer&nbsp;=&nbsp;ref&nbsp;0<br>
&nbsp;<span class="keyword">and</span>&nbsp;accu_complex&nbsp;=&nbsp;ref&nbsp;complex_0&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pp&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;clean_complex&nbsp;(&nbsp;matrix_complex_extract_diag_to_poly&nbsp;res.(0)&nbsp;)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;res.(1)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;nn&nbsp;/&nbsp;2&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;spectrum&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;n&nbsp;complex_0<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ppp&nbsp;=&nbsp;methode_tune_roots&nbsp;pp&nbsp;char_pol<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n_n&nbsp;=&nbsp;n&nbsp;-&nbsp;1<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;trans_passage&nbsp;=&nbsp;<span class="constructor">Array</span>.make_matrix&nbsp;nn&nbsp;nn&nbsp;0.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;ppp.(0).(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;candidate_value&nbsp;=&nbsp;p.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;difference&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_minus&nbsp;m&nbsp;(&nbsp;scal_complex&nbsp;n&nbsp;n&nbsp;candidate_value&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;test&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_invertibility&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;test&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.float_normalized_iterate&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;steps&nbsp;mm&nbsp;q.(i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(&nbsp;n&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;vector_complex_i_times&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ww&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;mm&nbsp;w<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;z&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;complex_vector_to_complex_poly&nbsp;ww&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;n_n&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;divisor&nbsp;=&nbsp;z.(j)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;complex_module&nbsp;divisor&nbsp;&gt;&nbsp;seuil&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;!accu_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_prod&nbsp;zz.(j)&nbsp;(&nbsp;complex_inv&nbsp;divisor&nbsp;)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;succ&nbsp;!accu_integer&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;coeff&nbsp;=&nbsp;clean_complex&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_float_scal_left_div&nbsp;(&nbsp;float&nbsp;!accu_integer&nbsp;)&nbsp;!accu_complex&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_complex&nbsp;:=&nbsp;complex_0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu_integer&nbsp;:=&nbsp;0&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;candidate_value&nbsp;(&nbsp;complex_inv&nbsp;coeff&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spectrum.(i)&nbsp;&lt;-&nbsp;candidate_value&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;k&nbsp;=&nbsp;methode_ker&nbsp;difference&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;kk&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;k&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;v&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_bal_random&nbsp;kk&nbsp;10.&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w_w&nbsp;=&nbsp;(&nbsp;<span class="constructor">Matrix</span>.matrix_vector_float_prod&nbsp;(&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;k&nbsp;)&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;(&nbsp;1.&nbsp;/.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;v&nbsp;)&nbsp;)&nbsp;v&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w_coeff&nbsp;=&nbsp;1.&nbsp;/.&nbsp;(&nbsp;<span class="constructor">Matrix</span>.vector_float_norm_2&nbsp;w_w&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;<span class="constructor">Matrix</span>.vector_float_scal_mult&nbsp;w_coeff&nbsp;w_w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(i)&nbsp;&lt;-&nbsp;<span class="constructor">Matrix</span>.vector_float_copy&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans_passage.(&nbsp;n&nbsp;+&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;vector_complex_i_times&nbsp;w&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;spectrum&nbsp;;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.float_transpose&nbsp;trans_passage&nbsp;|]&nbsp;;&nbsp;[|&nbsp;trans_passage&nbsp;&nbsp;|]&nbsp;|]&nbsp;;;&nbsp;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>demultip roots_and_multiplicity_array</pre> Input : roots; multiplicities.
Output : roots counted with respect to their multiplicities.
<p>

Entrée : racines ; multiplicités.
Sortie : racines comptées avec leur multiplicité. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;demultip&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(r:float&nbsp;array&nbsp;array&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;roots&nbsp;=&nbsp;r.(0)<br>
&nbsp;<span class="keyword">and</span>&nbsp;multiplicities&nbsp;=&nbsp;r.(1)<br>
&nbsp;<span class="keyword">and</span>&nbsp;s&nbsp;=&nbsp;ref&nbsp;[||]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;l&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;roots&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;l&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;int_of_float&nbsp;(&nbsp;complex_real_part&nbsp;multiplicities.(i)&nbsp;)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;<span class="constructor">Array</span>.append&nbsp;!s&nbsp;[|&nbsp;roots.(i)&nbsp;|]<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!s&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_det spectrum_method matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_det&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;spectrum_methode&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;spectrum_methode&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;vector_complex_contraction&nbsp;p&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>gauss_det spectrum_method matrix</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;gauss_det&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;spectrum_methode&nbsp;(m:int&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;mm&nbsp;=&nbsp;<span class="constructor">Array</span>.map&nbsp;(&nbsp;<span class="constructor">Array</span>.map&nbsp;float&nbsp;)&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;spectrum_methode&nbsp;mm&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">Matrix</span>.matrix_float_round&nbsp;(&nbsp;vector_complex_contraction&nbsp;p&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>complex_krylov_reduction apply_rule decomposition_polynomial methode_diag matrix</pre> Output: conjugate matrix (in the eigenbasis), 
matrix whose columns are the respective eigenvectors of the diagonalizable part, inverse of the preceding matrix, 
candidate for the diagonal matrix, conjugate matrix of the nilpotent part (in the eigenbasis), matrix whose rows are the eigenvectors of the diagonalizable part.
<p>

Sortie : matrice conjuguée (dans la base propre), matrice dont les colonnes sont les vecteurs propres de la partie diagonalisable, 
matrice inverse de la précédente, candidat pour la matrice diagonale, matrice conjuguée de la partie nilpotente (dans la base propre), 
matrice dont les lignes sont les vecteurs propres de la partie diagonalisable. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;complex_krylov_reduction&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;apply_rule&nbsp;(decomposition_polynomial:float&nbsp;array&nbsp;array&nbsp;array)&nbsp;methode_diag&nbsp;(m:float&nbsp;array&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;dec&nbsp;=&nbsp;jordan_decomposition&nbsp;apply_rule&nbsp;decomposition_polynomial&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;d&nbsp;=&nbsp;dec.(0)<br>
&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;n&nbsp;=&nbsp;dec.(1)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dd&nbsp;=&nbsp;methode_diag&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;dd.(1).(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;ddd&nbsp;=&nbsp;diag_complex&nbsp;dd.(0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;<span class="constructor">Matrix</span>.clean_inv&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nn&nbsp;=&nbsp;<span class="constructor">Matrix</span>.matrix_float_triple_prod&nbsp;q&nbsp;n&nbsp;p&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|&nbsp;<span class="constructor">Matrix</span>.matrix_float_plus&nbsp;nn&nbsp;ddd&nbsp;;&nbsp;p&nbsp;;&nbsp;q&nbsp;;&nbsp;ddd&nbsp;;&nbsp;nn&nbsp;;&nbsp;dd.(2).(0)&nbsp;|]&nbsp;;;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ § § </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">end</span></code></body></html>