<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Math" rel="Chapter" href="Math.html"><title>Math.Sparse_vector</title>
</head>
<body>
<code class="code"><span class="keyword">struct</span><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="1_Introduction"><h1>Introduction</h1></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(**
The mathematician will find in this module functors to handle sparse vectors 
with coefficients in a commutative rng or a field.
<p>

<span id="2_Conventions"><h2>Conventions</h2></span>
<p>

The indices are polymorphic and must be structured in a module.
The indices that immediately come to mind are in the types <code class="code">int</code>, <code class="code">int array</code>, <code class="code"><span class="constructor">Big_int</span>.big_int</code>, <code class="code"><span class="constructor">Big_int</span>.big_int array</code>.
For the multi-indices, the order may be lexicographic or anything else.
<p>

<span id="2_Comments"><h2>Comments</h2></span>
<p>

This module is inspired by the module <code class="code"><span class="constructor">Hashtbl</span></code> of the standard library of OCaml.
<p>

A function is <em>sealed</em> if there is no sharing between the input variables and the output value.
This is the expected behavior of usual mathematical functions.
Copy functions are provided.
They are sealed provided that they receive as argument elementary copy functions for coefficients and indices.
By composition, they permit to seal all functions necessary.
<p>

This module is distributed under the same licence as Ocaml.
<p>

<center>§ </center>
<p>

La mathématicienne ou le mathématicien trouvera dans ce module des foncteurs pour traiter 
les vecteurs creux à coefficients dans un annau commutatif ou bien dans un corps commutatif.
<p>

<span id="2_Conventions"><h2>Conventions</h2></span>
<p>

Les indices sont polymorphes et doivent être structurés dans un module.
Les indices qui viennent immédiatement à l'esprit sont dans les types <code class="code">int</code>, <code class="code">int array</code>, <code class="code"><span class="constructor">Big_int</span>.big_int</code>, <code class="code"><span class="constructor">Big_int</span>.big_int array</code>.
Pour les multi-indices, l'ordre peut être lexicographique ou autre.
<p>

<span id="2_Commentaires"><h2>Commentaires</h2></span>
<p>

Une fonction est <em>étanche</em> quand il n'y a aucun partage entre les variables fournies en entrée et la valeur obtenue en sortie.
C'est le comportement attendu des fonctions mathématiques habituelles. 
Des fonctions de recopie sont fournies.
Elles sont étanches à condition de leur fournir en argument des fonctions élémentaires de recopie des coefficients et des indices. 
Par composition, elle permettent d'étanchéifier toutes les fonctions voulues.
<p>

Ce module est inspiré du module <code class="code"><span class="constructor">Hashtbl</span></code> de la bibliothèque standard d'OCaml.
<p>

Ce module est distribué selon la même licence qu'Ocaml.
<p>

<center>Copyright Stéphane Grognet</center>
<center>Laboratoire de mathématiques Jean Leray UMR 6629 CNRS</center>
<center>Fédération de recherche mathématique des Pays de la Loire</center>
<center>Centre Henri Lebesgue</center>
<center>IREM des Pays de la Loire - Université de Nantes</center>
<center>version 0.1</center>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(**
@version 0.1
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(**
@author Stéphane Grognet
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(**
@since 2013
*)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Vecteurscreuxcoefficientsdansunannaucommutatif"><h2>Vecteurs creux à coefficients dans un annau commutatif</h2></span>
<span id="2_Sparsevectorswithcoefficientsinacommutativerng"><h2>Sparse vectors with coefficients in a commutative rng</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Util</span>&nbsp;;;<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Data</span>&nbsp;;;<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Hash</span>&nbsp;;;<br>
<br>
<br>
<br>
<span class="keyword">module</span>&nbsp;<span class="constructor">Rng</span>&nbsp;(<span class="constructor">Index</span>:<span class="constructor">Data</span>.<span class="constructor">Index_type</span>)&nbsp;(<span class="constructor">Hasher</span>:<span class="constructor">Hash</span>.<span class="constructor">Hash_type</span>&nbsp;<span class="keyword">with</span>&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Index</span>.t)&nbsp;(<span class="constructor">Coeff</span>:<span class="constructor">Data</span>.<span class="constructor">Rng_coeff_type</span>)&nbsp;=&nbsp;<span class="keyword">struct</span><br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** The type <code class="code">elt</code> consists in couples (index, weight) and is identified with the type <code class="code">elt</code> of the following module <code class="code"><span class="constructor">H</span></code>.
<p>

Le type <code class="code">elt</code> est formé par couple (indice, poids) et est identifié avec le type <code class="code">elt</code> du module <code class="code"><span class="constructor">H</span></code> suivant. *)</span></td></tr></table><code class="code"><br>
<br>
<span class="keyword">type</span>&nbsp;index&nbsp;=&nbsp;<span class="constructor">Index</span>.t&nbsp;;;<br>
<br>
<span class="keyword">type</span>&nbsp;coeff&nbsp;=&nbsp;<span class="constructor">Coeff</span>.t&nbsp;;;<br>
<br>
<span class="keyword">type</span>&nbsp;elt&nbsp;=&nbsp;index&nbsp;*&nbsp;coeff&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** The module <code class="code"><span class="constructor">H</span></code> provides the hash tables.
<p>

Le module <code class="code"><span class="constructor">H</span></code> fournit les tables de hachage. *)</span></td></tr></table><code class="code"><br>
<br>
<span class="keyword">module</span>&nbsp;<span class="constructor">H</span>&nbsp;=&nbsp;(&nbsp;<span class="constructor">Hash</span>.<span class="constructor">Make</span>&nbsp;(<span class="constructor">Index</span>)&nbsp;(<span class="constructor">Hasher</span>)&nbsp;(<span class="constructor">Coeff</span>)<br>
:&nbsp;<span class="keyword">sig</span><br>
&nbsp;<span class="keyword">include</span>&nbsp;<span class="keyword">module</span>&nbsp;<span class="keyword">type</span>&nbsp;<span class="keyword">of</span>&nbsp;<span class="constructor">Hash</span>.<span class="constructor">Make</span>&nbsp;(<span class="constructor">Index</span>)&nbsp;(<span class="constructor">Hasher</span>)&nbsp;(<span class="constructor">Coeff</span>)<br>
<span class="keyword">end</span><br>
&nbsp;<span class="keyword">with</span>&nbsp;<span class="keyword">type</span>&nbsp;elt&nbsp;:=&nbsp;elt&nbsp;<span class="keyword">with</span>&nbsp;<span class="keyword">type</span>&nbsp;index&nbsp;=&nbsp;index&nbsp;<span class="keyword">with</span>&nbsp;<span class="keyword">type</span>&nbsp;weight&nbsp;=&nbsp;coeff&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** The type <code class="code">t</code> contains the hash table together with the dimension of the vector space.
<p>

Le type <code class="code">t</code> contient la table de hachage avec la dimension de l'espace vectoriel. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;index&nbsp;*&nbsp;<span class="constructor">H</span>.t&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** The type <code class="code">t</code> is that of the norm.
<p>

Le type <code class="code">u</code> est celui de la norme. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">type</span>&nbsp;u&nbsp;=&nbsp;<span class="constructor">Coeff</span>.u&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>to_sparse hash_size vector</pre> This function is not sealed.
<p>

Cette fonction n'est pas étanche. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;to_sparse&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(size:int)&nbsp;(v:coeff&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;<span class="constructor">Array</span>.length&nbsp;v<br>
&nbsp;<span class="keyword">and</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.create&nbsp;size&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;pred&nbsp;r&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.add&nbsp;h&nbsp;(&nbsp;<span class="constructor">Index</span>.from_int&nbsp;i&nbsp;,&nbsp;v.(i)&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;<span class="keyword">done</span>&nbsp;;<br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.from_int&nbsp;r&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>auto_to_sparse vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;auto_to_sparse&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:coeff&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;to_sparse&nbsp;(&nbsp;-1&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>first_non_zero vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;first_non_zero&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;ref&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Index</span>.compare&nbsp;i&nbsp;!result&nbsp;&gt;&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;result&nbsp;:=&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!result&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>last_non_zero vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;last_non_zero&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Index</span>.witness&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Index</span>.compare&nbsp;i&nbsp;!result&nbsp;&gt;&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;result&nbsp;:=&nbsp;i&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!result&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>to_full vector</pre> This function is not sealed.
<p>

Cette fonction n'est pas étanche. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;to_full&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;max&nbsp;(&nbsp;<span class="constructor">Index</span>.to_int&nbsp;d&nbsp;)&nbsp;(&nbsp;succ&nbsp;(&nbsp;<span class="constructor">Index</span>.to_int&nbsp;(&nbsp;last_non_zero&nbsp;x&nbsp;)&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Array</span>.make&nbsp;r&nbsp;(&nbsp;<span class="constructor">Coeff</span>.zero&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;z&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;y.(&nbsp;<span class="constructor">Index</span>.to_int&nbsp;i&nbsp;)&nbsp;&lt;-&nbsp;z&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>filling vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;filling&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.filling&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>dimension vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;dimension&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>info vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;info&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;<span class="constructor">H</span>.filling&nbsp;v&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>size vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;size&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.size&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>null dimension</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;null&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(d:index)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;<span class="constructor">H</span>.create&nbsp;(&nbsp;-1&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>zero unit</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;zero&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;()&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.from_int&nbsp;1&nbsp;,&nbsp;<span class="constructor">H</span>.create&nbsp;(&nbsp;-1&nbsp;)&nbsp;)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>to_string vector</pre>*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;to_string&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Index</span>.to_string&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;ref&nbsp;<span class="string">""</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;z&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;b&nbsp;:=&nbsp;!b&nbsp;^&nbsp;<span class="string">"("</span>&nbsp;^&nbsp;(&nbsp;<span class="constructor">Index</span>.to_string&nbsp;i&nbsp;)&nbsp;^&nbsp;<span class="string">","</span>&nbsp;^&nbsp;(&nbsp;<span class="constructor">Coeff</span>.to_string&nbsp;z&nbsp;)&nbsp;^&nbsp;<span class="string">");"</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;a&nbsp;^&nbsp;<span class="string">":"</span>&nbsp;^&nbsp;(&nbsp;<span class="constructor">String</span>.sub&nbsp;!b&nbsp;0&nbsp;(&nbsp;max&nbsp;0&nbsp;(&nbsp;pred&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;!b&nbsp;)&nbsp;)&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>special_to_string dimension_separator beginning separator ending vector</pre>*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;special_to_string&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(dim_sep:char)&nbsp;(beginning:string)&nbsp;(separator:string)&nbsp;(ending:string)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">assert</span>&nbsp;(&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;beginning&nbsp;)&nbsp;+&nbsp;1&nbsp;=&nbsp;<span class="constructor">String</span>.length&nbsp;ending&nbsp;)&nbsp;;<br>
&nbsp;<span class="keyword">let</span>&nbsp;a&nbsp;=&nbsp;<span class="constructor">Index</span>.to_string&nbsp;d<br>
&nbsp;<span class="keyword">and</span>&nbsp;b&nbsp;=&nbsp;ref&nbsp;<span class="string">""</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;z&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;b&nbsp;:=&nbsp;!b&nbsp;^&nbsp;beginning&nbsp;^&nbsp;(&nbsp;<span class="constructor">Index</span>.to_string&nbsp;i&nbsp;)&nbsp;^&nbsp;separator&nbsp;^&nbsp;(&nbsp;<span class="constructor">Coeff</span>.to_string&nbsp;z&nbsp;)&nbsp;^&nbsp;ending&nbsp;<span class="keyword">in</span><br>
&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;a&nbsp;^&nbsp;(&nbsp;<span class="constructor">String</span>.make&nbsp;1&nbsp;dim_sep&nbsp;)&nbsp;^&nbsp;(&nbsp;<span class="constructor">String</span>.sub&nbsp;!b&nbsp;0&nbsp;(&nbsp;max&nbsp;0&nbsp;(&nbsp;pred&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;!b&nbsp;)&nbsp;)&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>print vector</pre>*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;print&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;print_string&nbsp;(&nbsp;to_string&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;print_newline&nbsp;()&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>from_string size string</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;from_string&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(size:int)&nbsp;(s:string)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;boundary&nbsp;separator&nbsp;st&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;lst&nbsp;=&nbsp;<span class="constructor">String</span>.length&nbsp;st&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;str&nbsp;=&nbsp;<span class="constructor">String</span>.sub&nbsp;st&nbsp;boundary&nbsp;(&nbsp;max&nbsp;0&nbsp;(&nbsp;lst&nbsp;-&nbsp;2&nbsp;*&nbsp;boundary&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Str</span>.split&nbsp;(&nbsp;<span class="constructor">Str</span>.regexp_string&nbsp;separator&nbsp;)&nbsp;str<br>
&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;separation&nbsp;=&nbsp;<span class="constructor">String</span>.index&nbsp;s&nbsp;<span class="string">':'</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dimension&nbsp;=&nbsp;<span class="constructor">String</span>.sub&nbsp;s&nbsp;0&nbsp;separation<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;sep&nbsp;=&nbsp;succ&nbsp;separation&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;content&nbsp;=&nbsp;<span class="constructor">String</span>.sub&nbsp;s&nbsp;sep&nbsp;(&nbsp;max&nbsp;0&nbsp;(&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;s&nbsp;)&nbsp;-&nbsp;sep&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;listing&nbsp;=&nbsp;f&nbsp;1&nbsp;<span class="string">");("</span>&nbsp;content<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;st&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;f&nbsp;0&nbsp;<span class="string">","</span>&nbsp;st&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;head&nbsp;::&nbsp;tail&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.of_string&nbsp;head&nbsp;,&nbsp;<span class="constructor">Coeff</span>.of_string&nbsp;(&nbsp;<span class="constructor">List</span>.hd&nbsp;tail&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Bad&nbsp;string&nbsp;in&nbsp;Sparse.Rng_vector.of_string."</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.of_list&nbsp;size&nbsp;(&nbsp;<span class="constructor">List</span>.rev_map&nbsp;g&nbsp;listing&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.of_string&nbsp;dimension&nbsp;,&nbsp;h&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null&nbsp;(&nbsp;<span class="constructor">Index</span>.of_string&nbsp;dimension&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>special_from_string dimension_separator beginning separator ending size string</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;special_from_string&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(dim_sep:char)&nbsp;(beginning:string)&nbsp;(separator:string)&nbsp;(ending:string)&nbsp;(size:int)&nbsp;(s:string)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">assert</span>&nbsp;(&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;beginning&nbsp;)&nbsp;+&nbsp;1&nbsp;=&nbsp;<span class="constructor">String</span>.length&nbsp;ending&nbsp;)&nbsp;;<br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;boundary&nbsp;separator&nbsp;st&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;lst&nbsp;=&nbsp;<span class="constructor">String</span>.length&nbsp;st&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;str&nbsp;=&nbsp;<span class="constructor">String</span>.sub&nbsp;st&nbsp;boundary&nbsp;(&nbsp;max&nbsp;0&nbsp;(&nbsp;lst&nbsp;-&nbsp;2&nbsp;*&nbsp;boundary&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Str</span>.split&nbsp;(&nbsp;<span class="constructor">Str</span>.regexp_string&nbsp;separator&nbsp;)&nbsp;str<br>
&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;separation&nbsp;=&nbsp;<span class="constructor">String</span>.index&nbsp;s&nbsp;dim_sep&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;dimension&nbsp;=&nbsp;<span class="constructor">String</span>.sub&nbsp;s&nbsp;0&nbsp;separation<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;sep&nbsp;=&nbsp;succ&nbsp;separation&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;content&nbsp;=&nbsp;<span class="constructor">String</span>.sub&nbsp;s&nbsp;sep&nbsp;(&nbsp;max&nbsp;0&nbsp;(&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;s&nbsp;)&nbsp;-&nbsp;sep&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;listing&nbsp;=&nbsp;f&nbsp;(&nbsp;<span class="constructor">String</span>.length&nbsp;beginning&nbsp;)&nbsp;(&nbsp;ending&nbsp;^&nbsp;beginning&nbsp;)&nbsp;content<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;g&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;st&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;f&nbsp;0&nbsp;separator&nbsp;st&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;head&nbsp;::&nbsp;tail&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.of_string&nbsp;head&nbsp;,&nbsp;<span class="constructor">Coeff</span>.of_string&nbsp;(&nbsp;<span class="constructor">List</span>.hd&nbsp;tail&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Bad&nbsp;string&nbsp;in&nbsp;Sparse.Rng_vector.of_string."</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.of_list&nbsp;size&nbsp;(&nbsp;<span class="constructor">List</span>.rev_map&nbsp;g&nbsp;listing&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.of_string&nbsp;dimension&nbsp;,&nbsp;h&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null&nbsp;(&nbsp;<span class="constructor">Index</span>.of_string&nbsp;dimension&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>of_string string</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;of_string&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(s:string)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;from_string&nbsp;(&nbsp;-1&nbsp;)&nbsp;s&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>copy vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;copy&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;i&nbsp;,&nbsp;<span class="constructor">Coeff</span>.copy&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;vv&nbsp;=&nbsp;<span class="constructor">H</span>.copy&nbsp;f&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;vv&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>cleanup vector</pre> This function is needed in case the indices are modified in place.
<p>

Cette fonction est nécessaire si l'on modifie en place les indices. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;cleanup&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;<span class="constructor">H</span>.size&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;max&nbsp;1&nbsp;s&nbsp;<span class="keyword">else</span>&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.resize&nbsp;t&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>resize size vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;resize&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(n:int)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;t&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;&gt;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;max&nbsp;1&nbsp;n&nbsp;<span class="keyword">else</span>&nbsp;n&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.resize&nbsp;t&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>elements vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;elements&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.elements&nbsp;v&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>iter function vector</pre> This function is applied in place.
<p>

Cette fonction est appliquée en place. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;iter&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;f&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>fold function vector init</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;fold&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;f&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;init&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.fold&nbsp;f&nbsp;v&nbsp;init&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_map function vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_map&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;f&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;f&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_mapi function vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_mapi&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;f&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_mapi&nbsp;f&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>map function vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;map&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;f&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;<span class="constructor">H</span>.map&nbsp;f&nbsp;v&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>mapi function vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;mapi&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;f&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;<span class="constructor">H</span>.mapi&nbsp;f&nbsp;v&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>min vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;min&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.min&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>max vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;max&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.max&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>unsafe_extract index vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;unsafe_extract&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.extract&nbsp;i&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>extract index vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;extract&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.extract&nbsp;i&nbsp;v<br>
&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.zero&nbsp;()&nbsp;,&nbsp;<span class="constructor">Coeff</span>.zero&nbsp;()&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>raw_extract index vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;raw_extract&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;snd&nbsp;(&nbsp;extract&nbsp;i&nbsp;x&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>filter predicate vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;filter&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(p:index&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;bool)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;ref&nbsp;[]&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;p(i)&nbsp;<span class="keyword">then</span>&nbsp;result&nbsp;:=&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;::&nbsp;!result&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!result&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>insert_add coefficient index vector</pre> This function is applied in place.
<p>

Cette fonction est appliquée en place. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;insert_add&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:coeff)&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.add&nbsp;v&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>insert_sub coefficient index vector</pre> This function is applied in place.
<p>

Cette fonction est appliquée en place. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;insert_sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:coeff)&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.sub&nbsp;v&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>replace coefficient index vector</pre> This function is applied in place.
<p>

Cette fonction est appliquée en place. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;replace&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:coeff)&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.replace&nbsp;v&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>remove index vector</pre> This function is applied in place.
<p>

Cette fonction est appliquée en place. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;remove&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;raw_extract&nbsp;i&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.remove&nbsp;v&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>beginning index vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;beginning&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x&nbsp;:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;null&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;j&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;j&nbsp;i&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;j&nbsp;(&nbsp;<span class="constructor">Index</span>.zero&nbsp;()&nbsp;)&nbsp;&gt;=&nbsp;0&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;insert_add&nbsp;y&nbsp;j&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;iter&nbsp;f&nbsp;x&nbsp;;<br>
&nbsp;&nbsp;&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>ending index vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;ending&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x&nbsp;:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;w&nbsp;=&nbsp;null&nbsp;d&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;j&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;j&nbsp;i&nbsp;&gt;=&nbsp;0&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;j&nbsp;d&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;<span class="keyword">then</span>&nbsp;insert_add&nbsp;y&nbsp;j&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;iter&nbsp;f&nbsp;x&nbsp;;<br>
&nbsp;&nbsp;&nbsp;w&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_add vector1 vector2</pre> The first vector stores the result.
<p>

Le premier vecteur accueille le résultat. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_add&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;((&nbsp;e&nbsp;,&nbsp;w&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">H</span>.add&nbsp;v&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>add vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;add&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;((&nbsp;e&nbsp;,&nbsp;w&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;y:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;xx&nbsp;=&nbsp;copy&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;in_place_add&nbsp;xx&nbsp;y&nbsp;;<br>
&nbsp;&nbsp;xx&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_sub vector1 vector2</pre> The first vector stores the result.
<p>

Le premier vecteur accueille le résultat. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;((&nbsp;e&nbsp;,&nbsp;w&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">H</span>.sub&nbsp;v&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;w&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sub vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;((&nbsp;e&nbsp;,&nbsp;w&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;y:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;xx&nbsp;=&nbsp;copy&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;in_place_sub&nbsp;xx&nbsp;y&nbsp;;<br>
&nbsp;&nbsp;xx&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>eq_zero vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;eq_zero&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">H</span>.filling&nbsp;v&nbsp;)&nbsp;=&nbsp;0&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>eq vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;eq&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:t)&nbsp;(y:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;eq_zero&nbsp;(&nbsp;sub&nbsp;x&nbsp;y&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_opp vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_opp&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_opp&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>opp vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;opp&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;<span class="constructor">H</span>.opp&nbsp;v&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sub_vector beginning ending vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sub_vector&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(beginning:index)&nbsp;(ending:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.create&nbsp;(&nbsp;size&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;i&nbsp;beginning&nbsp;&gt;=&nbsp;0&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;i&nbsp;ending&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.add&nbsp;h&nbsp;(&nbsp;<span class="constructor">Index</span>.sub&nbsp;i&nbsp;beginning&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.succ&nbsp;(&nbsp;<span class="constructor">Index</span>.sub&nbsp;ending&nbsp;beginning&nbsp;)&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>mask_vector beginning ending vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;mask_vector&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(beginning:index)&nbsp;(ending:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.create&nbsp;(&nbsp;size&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;i&nbsp;beginning&nbsp;&gt;=&nbsp;0&nbsp;)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;i&nbsp;ending&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.add&nbsp;h&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;(&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>embed dimension shift vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;embed&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(dimension:index)&nbsp;(shift:index)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;<span class="keyword">as</span>&nbsp;x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">assert</span>&nbsp;(&nbsp;<span class="constructor">Index</span>.compare&nbsp;dimension&nbsp;(&nbsp;<span class="constructor">Index</span>.add&nbsp;shift&nbsp;d&nbsp;)&nbsp;&gt;=&nbsp;0&nbsp;)&nbsp;;<br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.create&nbsp;(&nbsp;size&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">H</span>.add&nbsp;h&nbsp;(&nbsp;<span class="constructor">Index</span>.add&nbsp;shift&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;<span class="constructor">H</span>.iter&nbsp;f&nbsp;v&nbsp;;<br>
&nbsp;&nbsp;&nbsp;(&nbsp;dimension&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>find coefficient vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;find&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(c:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;fst&nbsp;(&nbsp;<span class="constructor">H</span>.load_find&nbsp;v&nbsp;c&nbsp;)<br>
&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;<span class="constructor">Index</span>.witness&nbsp;()&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>find_all coefficient vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;find_all&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(c:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.load_find_all&nbsp;v&nbsp;c&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>list_find_all coefficient vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;list_find_all&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(c:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.<span class="constructor">B</span>.<span class="constructor">E</span>.elements&nbsp;(&nbsp;<span class="constructor">H</span>.load_find_all&nbsp;v&nbsp;c&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>index_list_find_all coefficient vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;index_list_find_all&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(c:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;)&nbsp;:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">List</span>.rev_map&nbsp;fst&nbsp;(&nbsp;<span class="constructor">H</span>.<span class="constructor">B</span>.<span class="constructor">E</span>.elements&nbsp;(&nbsp;<span class="constructor">H</span>.load_find_all&nbsp;v&nbsp;c&nbsp;)&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sum vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sum&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Coeff</span>.zero&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Coeff</span>.add&nbsp;!accu&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;ignore&nbsp;(&nbsp;iter&nbsp;f&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>contraction init vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;contraction&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(init:coeff)&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;init&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;!accu&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;ignore&nbsp;(&nbsp;iter&nbsp;f&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_scal_add scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_scal_add&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.add&nbsp;y&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_add scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_add&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.add&nbsp;y&nbsp;)&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_scal_mult scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_scal_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;y&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_mult scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;y&nbsp;)&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_scal_right_sub scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_scal_right_sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.sub&nbsp;y&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_right_sub scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_right_sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.sub&nbsp;y&nbsp;)&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_scal_left_sub scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_scal_left_sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Coeff</span>.sub&nbsp;z&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;f&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_left_sub scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_left_sub&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Coeff</span>.sub&nbsp;z&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;f&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>coeff_prod vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;coeff_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(x:t)&nbsp;(y:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;result&nbsp;=&nbsp;null&nbsp;(&nbsp;dimension&nbsp;x&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;z&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;raw_extract&nbsp;i&nbsp;x&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert_add&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;zz&nbsp;z&nbsp;)&nbsp;i&nbsp;result<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;iter&nbsp;f&nbsp;y&nbsp;;<br>
&nbsp;&nbsp;&nbsp;result&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_prod vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;((&nbsp;e&nbsp;,&nbsp;w&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;previous&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;<span class="constructor">H</span>.extract&nbsp;i&nbsp;w&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Coeff</span>.add&nbsp;previous&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;x&nbsp;(&nbsp;snd&nbsp;zz&nbsp;)&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;previous<br>
&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.fold&nbsp;f&nbsp;v&nbsp;(&nbsp;<span class="constructor">Coeff</span>.zero&nbsp;()&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>sparse_full_scal_prod vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;sparse_full_scal_prod&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;(w:coeff&nbsp;array)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;x&nbsp;)&nbsp;previous&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zz&nbsp;=&nbsp;w.(&nbsp;<span class="constructor">Index</span>.to_int&nbsp;i&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Coeff</span>.add&nbsp;previous&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;x&nbsp;zz&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;previous<br>
&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.fold&nbsp;f&nbsp;v&nbsp;(&nbsp;<span class="constructor">Coeff</span>.zero&nbsp;()&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_1 vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_1&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Coeff</span>.norm_zero&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Coeff</span>.norm_add&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Coeff</span>.norm&nbsp;y&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;ignore&nbsp;(&nbsp;iter&nbsp;f&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_inf vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_inf&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Coeff</span>.norm_zero&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;new_norm&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Coeff</span>.norm_compare&nbsp;new_norm&nbsp;!accu&nbsp;&gt;&nbsp;0&nbsp;<span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accu&nbsp;:=&nbsp;new_norm<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;ignore&nbsp;(&nbsp;iter&nbsp;f&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>square_sum vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;square_sum&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Coeff</span>.zero&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Coeff</span>.add&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;y&nbsp;y&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;ignore&nbsp;(&nbsp;iter&nbsp;f&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>square_norm_2 vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;square_norm_2&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;accu&nbsp;=&nbsp;ref&nbsp;(&nbsp;<span class="constructor">Coeff</span>.norm_zero&nbsp;()&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(&nbsp;i&nbsp;,&nbsp;y&nbsp;)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;accu&nbsp;:=&nbsp;<span class="constructor">Coeff</span>.norm_add&nbsp;!accu&nbsp;(&nbsp;<span class="constructor">Coeff</span>.norm&nbsp;(&nbsp;<span class="constructor">Coeff</span>.mult&nbsp;y&nbsp;y&nbsp;)&nbsp;)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;ignore&nbsp;(&nbsp;iter&nbsp;f&nbsp;x&nbsp;)&nbsp;;<br>
&nbsp;&nbsp;&nbsp;!accu&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>compare_norm norm vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;compare_norm&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;n&nbsp;(x:t)&nbsp;(y:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Coeff</span>.norm_compare&nbsp;(&nbsp;n&nbsp;x&nbsp;)&nbsp;(&nbsp;n&nbsp;y&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>exchange index_1 index_2 vector</pre> *)</span></td></tr></table><code class="code">&nbsp;<br>
<span class="keyword">let</span>&nbsp;exchange&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(i:index)&nbsp;(j:index)&nbsp;(u:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;(&nbsp;ii&nbsp;,&nbsp;x&nbsp;)&nbsp;=&nbsp;extract&nbsp;i&nbsp;u<br>
&nbsp;<span class="keyword">and</span>&nbsp;(&nbsp;jj&nbsp;,&nbsp;y&nbsp;)&nbsp;=&nbsp;extract&nbsp;j&nbsp;u&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;replace&nbsp;x&nbsp;j&nbsp;u&nbsp;;<br>
&nbsp;&nbsp;replace&nbsp;y&nbsp;i&nbsp;u&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>compare vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;compare&nbsp;=&nbsp;compare_norm&nbsp;norm_1&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>mult vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;mult&nbsp;=&nbsp;coeff_prod&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>square vector1 vector2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;square&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;mult&nbsp;x&nbsp;x&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_mult integer vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_mult&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(n:int)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.int_mult&nbsp;n&nbsp;)&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>int_pow integer vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;int_pow&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(n:int)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.int_pow&nbsp;n&nbsp;)&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm&nbsp;=&nbsp;norm_1&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_inject number</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_inject&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(x:u)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;auto_to_sparse&nbsp;[|&nbsp;<span class="constructor">Coeff</span>.norm_inject&nbsp;x&nbsp;|]&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_zero unit</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_zero&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;()&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">Coeff</span>.norm_zero&nbsp;()&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_of_string string</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_of_string&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_of_string&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_to_string number</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_to_string&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_to_string&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_print number</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_print&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_print&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_eq number1 number2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_eq&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_eq&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_eq_zero number</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_eq_zero&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_eq_zero&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_compare number1 number2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_compare&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_compare&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_add number1 number2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_add&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_add&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_int_mult integer number</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_int_mult&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_int_mult&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_mult number1 number2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_mult&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_mult&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_square number1 number2</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_square&nbsp;=&nbsp;<span class="constructor">Coeff</span>.norm_square&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ § § </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ </center> *)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** 
<span id="2_Vecteurscreuxcoefficientsdansuncorpscommutatif"><h2>Vecteurs creux à coefficients dans un corps commutatif</h2></span>
<span id="2_Sparsevectorswithcoefficientsinafield"><h2>Sparse vectors with coefficients in a field</h2></span>
*)</span></td></tr></table><code class="code"><br>
</code><table><tr><td></td><td><span class="comment">(** <center> </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">module</span>&nbsp;<span class="constructor">Field</span>&nbsp;(<span class="constructor">Index</span>:<span class="constructor">Data</span>.<span class="constructor">Index_type</span>)&nbsp;(<span class="constructor">Hasher</span>:<span class="constructor">Hash</span>.<span class="constructor">Hash_type</span>&nbsp;<span class="keyword">with</span>&nbsp;<span class="keyword">type</span>&nbsp;t&nbsp;=&nbsp;<span class="constructor">Index</span>.t)&nbsp;(<span class="constructor">Coeff</span>:<span class="constructor">Data</span>.<span class="constructor">Field_coeff_type</span>)&nbsp;=&nbsp;<span class="keyword">struct</span><br>
<br>
<br>
<span class="keyword">include</span>&nbsp;<span class="constructor">Rng</span>&nbsp;(<span class="constructor">Index</span>)&nbsp;(<span class="constructor">Hasher</span>)&nbsp;(<span class="constructor">Coeff</span>)&nbsp;;;<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_inv vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_inv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;<span class="constructor">Coeff</span>.inv&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>inv vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;inv&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;<span class="constructor">H</span>.map&nbsp;<span class="constructor">Coeff</span>.inv&nbsp;v&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_scal_right_div scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_scal_right_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.div&nbsp;y&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_right_div scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_right_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;(&nbsp;<span class="constructor">Coeff</span>.div&nbsp;y&nbsp;)&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>in_place_scal_left_div scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;in_place_scal_left_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Coeff</span>.div&nbsp;z&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">H</span>.in_place_map&nbsp;f&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>scal_left_div scalar vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;scal_left_div&nbsp;=&nbsp;<span class="keyword">fun</span>&nbsp;(y:coeff)&nbsp;((&nbsp;d&nbsp;,&nbsp;v&nbsp;):t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;z&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Coeff</span>.div&nbsp;z&nbsp;y&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;h&nbsp;=&nbsp;<span class="constructor">H</span>.map&nbsp;f&nbsp;v&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;(&nbsp;<span class="constructor">Index</span>.copy&nbsp;d&nbsp;,&nbsp;h&nbsp;)&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>reciprocal vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;reciprocal&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;scal_left_div&nbsp;(&nbsp;square_sum&nbsp;v&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <pre>norm_reciprocal vector</pre> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;norm_reciprocal&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;(v:t)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;scal_left_div&nbsp;(&nbsp;<span class="constructor">Coeff</span>.norm_inject&nbsp;(&nbsp;square_norm_2&nbsp;v&nbsp;)&nbsp;)&nbsp;v&nbsp;;;<br>
<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ § § </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">end</span>&nbsp;;;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <center>§ § § </center> *)</span></td></tr></table><code class="code"><br>
<br>
<br>
<br>
<br>
<span class="keyword">end</span></code></body></html>